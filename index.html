<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WWII Tower Defense - Improved</title>
  <style>
    body { margin: 0; padding: 0; font-family: 'Courier New', monospace; background-color: #222; color: #fff; }
    #game-container { position: relative; width: 800px; height: 500px; margin: 20px auto; overflow: hidden; box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); }
    #game-board { position: relative; width: 100%; height: 100%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="%233d4c2e" /><rect x="0" y="0" width="50" height="50" fill="%233a4929" opacity="0.4" /><rect x="50" y="50" width="50" height="50" fill="%233a4929" opacity="0.4" /></svg>'); }
    
    /* Terrain elements */
    .terrain { position: absolute; pointer-events: none; }
    .tree { width: 30px; height: 30px; font-size: 24px; text-align: center; }
    .rock { width: 20px; height: 20px; background-color: #777; border-radius: 5px; opacity: 0.8; }
    
    /* Improved path styling */
    .path { position: absolute; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60"><rect width="60" height="60" fill="%238B4513" opacity="0.6" /><line x1="0" y1="20" x2="60" y2="20" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /><line x1="0" y1="40" x2="60" y2="40" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /></svg>'); pointer-events: none; }
    
    /* Keep all other styles from original game */
    #info-panel { width: 800px; margin: 0 auto; display: flex; justify-content: space-between; padding: 10px; background-color: #3a3a3a; border: 3px solid #8b7d39; border-top: none; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
    #tower-selection { display: flex; gap: 10px; }
    .tower-option { width: 60px; height: 60px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px solid #777; border-radius: 5px; background-color: #444; transition: all 0.2s; }
    .tower-option:hover { background-color: #555; transform: translateY(-3px); }
    .tower-option.selected { border-color: #ffcc00; box-shadow: 0 0 10px #ffcc00; }
    .tower-icon { font-size: 24px; margin-bottom: 5px; }
    .tower-cost { font-size: 12px; font-weight: bold; color: #ffcc00; }
    .tower { position: absolute; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 10; font-size: 20px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
    .tower:hover { box-shadow: 0 0 8px 3px #ffcc00; }
    .tower.mg { background-color: #3a3a3a; border: 2px solid #6e6e6e; }
    .tower.artillery { background-color: #2d572c; border: 2px solid #4a7b49; }
    .tower.aa { background-color: #1a3e5c; border: 2px solid #3a6da3; }
    .tower.sniper { background-color: #5c2b1a; border: 2px solid #8a4f3b; }
    .tower-range { position: absolute; border-radius: 50%; background-color: rgba(255, 240, 130, 0.15); border: 1px dashed rgba(255, 204, 0, 0.3); pointer-events: none; z-index: 5; display: none; }
    .bullet { position: absolute; width: 6px; height: 6px; border-radius: 50%; z-index: 8; }
    .bullet.mg { background-color: #ffcc00; }
    .bullet.artillery { background-color: #ff6600; width: 8px; height: 8px; }
    .bullet.aa { background-color: #00ccff; }
    .bullet.sniper { background-color: #ff0000; width: 4px; height: 10px; }
    .explosion { position: absolute; width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle, rgba(255,102,0,0.8) 0%, rgba(255,153,0,0.6) 40%, rgba(255,204,0,0.2) 70%, rgba(255,204,0,0) 100%); z-index: 8; transform: translate(-50%, -50%); animation: explode 0.5s forwards; }
    @keyframes explode { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }
    .enemy { position: absolute; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 9; border-radius: 3px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
    .enemy.infantry { background-color: #8b0000; border: 1px solid #ff0000; }
    .enemy.tank { background-color: #b22222; width: 35px; height: 35px; border: 1px solid #ff3333; }
    .enemy.heavytank { background-color: #8b4500; width: 40px; height: 40px; border: 1px solid #ff7700; }
    .enemy.aircraft { background-color: #4b0082; border: 1px solid #9370db; }
    .enemy.elite { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    .health-bar { position: absolute; width: 30px; height: 4px; background-color: #333; top: -8px; left: 0; border-radius: 2px; overflow: hidden; }
    .health-fill { height: 100%; background-color: #32cd32; width: 100%; transition: width 0.2s; }
    #start-button { padding: 8px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
    #start-button:hover { background-color: #3e8e41; }
    #start-button:disabled { background-color: #cccccc; cursor: not-allowed; }
    #wave-info, #resources, #lives, #score-display { font-size: 16px; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; margin-right: 10px; }
    #wave-info { color: #ffcc00; }
    #resources { color: #32cd32; }
    #lives { color: #ff6666; }
    #score-display { color: #66ccff; }
    #game-over, #level-complete { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 10px; text-align: center; display: none; z-index: 100; border: 3px solid #8b7d39; box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); width: 300px; }
    .game-over-title { color: #ff6666; margin-top: 0; font-size: 28px; }
    .victory-title { color: #32cd32; margin-top: 0; font-size: 28px; }
    .final-score { font-size: 20px; margin: 15px 0; color: #ffcc00; }
    button.restart { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 15px; cursor: pointer; font-size: 16px; }
    button.restart:hover { background-color: #3e8e41; }
    #instructions { width: 800px; margin: 10px auto; background-color: #3a3a3a; padding: 15px; border: 3px solid #8b7d39; border-radius: 5px; margin-bottom: 20px; }
    .difficulty-selection { display: flex; gap: 10px; margin-top: 10px; }
    .difficulty-btn { padding: 8px 15px; background-color: #555; border: none; color: white; border-radius: 5px; cursor: pointer; flex: 1; }
    .difficulty-btn:hover { background-color: #666; }
    .difficulty-btn.selected { background-color: #4CAF50; font-weight: bold; }
    .upgrade-panel { display: none; position: absolute; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #ffcc00; border-radius: 5px; padding: 10px; z-index: 20; width: 150px; }
    .upgrade-option { margin-bottom: 8px; cursor: pointer; padding: 5px; background-color: #444; border-radius: 3px; }
    .upgrade-option:hover { background-color: #555; }
    .upgrade-option.disabled { opacity: 0.5; cursor: not-allowed; }
    .close-panel { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; font-size: 14px; }
    .ammo-bar { position: absolute; bottom: -8px; left: 0; width: 30px; height: 3px; background-color: #333; border-radius: 1px; overflow: hidden; }
    .ammo-fill { height: 100%; background-color: #ffaa00; width: 100%; }
  </style>
</head>
<body>
  <div id="instructions">
    <h2 style="margin-top: 0;">WWII Tower Defense</h2>
    <p>Select a tower, place it on the map (avoiding the path), and defend against waves of enemies!</p>
    <p><strong>Towers:</strong></p>
    <p>Machine Gun (üë®‚Äçü¶Ø) - good against infantry, Artillery (üí£) - area damage, Anti-Air (‚ö°) - counters aircraft, Sniper (üî≠) - high damage</p>
    <div class="difficulty-selection">
      <button class="difficulty-btn selected" data-difficulty="normal">Normal</button>
      <button class="difficulty-btn" data-difficulty="hard">Hard</button>
      <button class="difficulty-btn" data-difficulty="veteran">Veteran</button>
    </div>
  </div>
  
  <div id="game-container">
    <div id="game-board">
      <!-- Paths will be created dynamically -->
    </div>
    <div id="game-over">
      <h2 class="game-over-title">Game Over!</h2>
      <p>Your base was overrun!</p>
      <div class="final-score">Final Score: <span id="final-score">0</span></div>
      <button class="restart" onclick="restartGame()">Try Again</button>
    </div>
    <div id="level-complete">
      <h2 class="victory-title">Victory!</h2>
      <p>You successfully defended your position!</p>
      <div class="final-score">Final Score: <span id="victory-score">0</span></div>
      <button class="restart" onclick="restartGame()">Play Again</button>
    </div>
  </div>
  
  <div id="info-panel">
    <div style="display: flex;">
      <div id="wave-info">Wave: 0/12</div>
      <div id="resources">Resources: 150</div>
      <div id="lives">Base Health: 20/20</div>
      <div id="score-display">Score: 0</div>
    </div>
    <div id="tower-selection">
      <div class="tower-option" data-type="mg" onclick="selectTower('mg')">
        <div class="tower-icon">üë®‚Äçü¶Ø</div>
        <div class="tower-cost">$25</div>
      </div>
      <div class="tower-option" data-type="artillery" onclick="selectTower('artillery')">
        <div class="tower-icon">üí£</div>
        <div class="tower-cost">$50</div>
      </div>
      <div class="tower-option" data-type="aa" onclick="selectTower('aa')">
        <div class="tower-icon">‚ö°</div>
        <div class="tower-cost">$40</div>
      </div>
      <div class="tower-option" data-type="sniper" onclick="selectTower('sniper')">
        <div class="tower-icon">üî≠</div>
        <div class="tower-cost">$60</div>
      </div>
    </div>
    <button id="start-button" onclick="startWave()">Start Wave 1</button>
  </div>

  <div class="upgrade-panel" id="upgrade-panel">
    <div class="close-panel" onclick="closeUpgradePanel()">‚úï</div>
    <div class="upgrade-option" id="upgrade-damage" onclick="upgradeTower('damage')">Damage +25% ($30)</div>
    <div class="upgrade-option" id="upgrade-range" onclick="upgradeTower('range')">Range +15% ($25)</div>
    <div class="upgrade-option" id="upgrade-rate" onclick="upgradeTower('rate')">Fire Rate +20% ($35)</div>
  </div>

  <script>
    // Game state
    const gameState = {
      resources: 150, lives: 20, currentWave: 0, maxWaves: 12, waveInProgress: false,
      gameOver: false, victory: false, score: 0, selectedTowerType: null, selectedTower: null,
      towers: [], enemies: [], bullets: [], animationFrameId: null, difficulty: 'normal',
      lastFrameTime: 0, terrainElements: [], frameCounter: 0, enemySpeedMultiplier: 0.025
    };

    // Define curved path coordinates (more realistic path)
    const pathSegments = [
      { type: 'curved', points: [{ x: 150, y: -30 }, { x: 180, y: 100 }, { x: 230, y: 250 }, { x: 230, y: 330 }] },
      { type: 'curved', points: [{ x: 230, y: 330 }, { x: 270, y: 350 }, { x: 320, y: 350 }, { x: 400, y: 330 }] },
      { type: 'curved', points: [{ x: 400, y: 330 }, { x: 430, y: 300 }, { x: 430, y: 250 }, { x: 400, y: 180 }] },
      { type: 'curved', points: [{ x: 400, y: 180 }, { x: 450, y: 170 }, { x: 500, y: 180 }, { x: 600, y: 180 }] }
    ];

    // Generate path points for enemy movement
    const path = [];
    const pathResolution = 10; // Points per segment
    pathSegments.forEach(segment => {
      if (segment.type === 'curved') {
        // Generate points along Bezier curve
        for (let t = 0; t <= 1; t += 1/pathResolution) {
          const points = segment.points;
          // Cubic Bezier formula
          const x = Math.pow(1-t, 3) * points[0].x + 
                  3 * Math.pow(1-t, 2) * t * points[1].x + 
                  3 * (1-t) * Math.pow(t, 2) * points[2].x + 
                  Math.pow(t, 3) * points[3].x;
          const y = Math.pow(1-t, 3) * points[0].y + 
                  3 * Math.pow(1-t, 2) * t * points[1].y + 
                  3 * (1-t) * Math.pow(t, 2) * points[2].y + 
                  Math.pow(t, 3) * points[3].y;
          path.push({ x, y });
        }
      }
    });

    // Tower definitions
    const towerTypes = {
      mg: { name: "Machine Gun", cost: 25, damage: 1, range: 120, fireRate: 500, targets: ["infantry", "tank", "heavytank"], icon: "üë®‚Äçü¶Ø", ammo: 20, maxAmmo: 20, reloadTime: 2000 },
      artillery: { name: "Artillery", cost: 50, damage: 3, range: 180, fireRate: 2000, targets: ["infantry", "tank", "heavytank"], icon: "üí£", splash: 60, ammo: 3, maxAmmo: 3, reloadTime: 5000 },
      aa: { name: "Anti-Air", cost: 40, damage: 2, range: 150, fireRate: 800, targets: ["aircraft"], icon: "‚ö°", ammo: 15, maxAmmo: 15, reloadTime: 3000 },
      sniper: { name: "Sniper", cost: 60, damage: 6, range: 250, fireRate: 3000, targets: ["infantry", "tank", "heavytank"], icon: "üî≠", ammo: 5, maxAmmo: 5, reloadTime: 4000 }
    };

    // Enemy definitions
    const enemyTypes = {
      infantry: { name: "Infantry", health: 3, speed: 1, worth: 5, damage: 1, icon: "üë§", scoreValue: 10 },
      tank: { name: "Tank", health: 8, speed: 0.5, worth: 10, damage: 2, icon: "üöú", scoreValue: 25 },
      heavytank: { name: "Heavy Tank", health: 20, speed: 0.3, worth: 20, damage: 4, icon: "üöõ", scoreValue: 50 },
      aircraft: { name: "Aircraft", health: 4, speed: 1.5, worth: 8, damage: 1, icon: "‚úàÔ∏è", scoreValue: 20 }
    };

    // Elite enemy modifiers
    const eliteModifiers = { health: 2, speed: 1.2, worth: 2, scoreValue: 2 };

    // Wave definitions
    const waveDefinitions = [
      { infantry: 10 },
      { infantry: 15, tank: 2 },
      { infantry: 10, aircraft: 5 },
      { infantry: 15, tank: 5 },
      { infantry: 10, tank: 5, aircraft: 5 },
      { infantry: 20, tank: 8 },
      { heavytank: 2, infantry: 10, aircraft: 8 },
      { infantry: 15, tank: 5, aircraft: 10 },
      { infantry: 15, tank: 10, aircraft: 5, heavytank: 2 },
      { infantry: 20, tank: 10, aircraft: 10 },
      { infantry: 25, tank: 15, aircraft: 10, elites: ["tank"] },
      { infantry: 30, tank: 20, aircraft: 15, heavytank: 10, elites: ["heavytank", "aircraft"] }
    ];

    // Difficulty settings
    const difficultySettings = {
      normal: { enemyHealthMultiplier: 1, enemySpeedMultiplier: 1, resourceMultiplier: 1, waveSpawnDelay: 800 },
      hard: { enemyHealthMultiplier: 1.5, enemySpeedMultiplier: 1.2, resourceMultiplier: 0.8, waveSpawnDelay: 600 },
      veteran: { enemyHealthMultiplier: 2, enemySpeedMultiplier: 1.4, resourceMultiplier: 0.6, waveSpawnDelay: 400 }
    };

    // DOM Elements
    const gameBoard = document.getElementById('game-board');
    const waveInfoElement = document.getElementById('wave-info');
    const resourcesElement = document.getElementById('resources');
    const livesElement = document.getElementById('lives');
    const scoreElement = document.getElementById('score-display');
    const startButton = document.getElementById('start-button');
    const gameOverPanel = document.getElementById('game-over');
    const levelCompletePanel = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const victoryScoreElement = document.getElementById('victory-score');
    const upgradePanel = document.getElementById('upgrade-panel');

    // Create path visualization
    function createPathVisualization() {
      // Create path segments
      pathSegments.forEach((segment, i) => {
        if (segment.type === 'curved') {
          const points = segment.points;
          // Create path element for this segment
          const pathElement = document.createElement('div');
          pathElement.className = 'path';
          
          // Set path dimensions and position based on the points
          const startX = Math.min(...points.map(p => p.x));
          const startY = Math.min(...points.map(p => p.y));
          const endX = Math.max(...points.map(p => p.x));
          const endY = Math.max(...points.map(p => p.y));
          
          pathElement.style.left = `${startX - 30}px`;
          pathElement.style.top = `${startY}px`;
          pathElement.style.width = `${endX - startX + 60}px`;
          pathElement.style.height = `${endY - startY + 60}px`;
          
          // Use clip-path for curved paths
          const clipPoints = [];
          for (let t = 0; t <= 1; t += 0.01) {
            const x = Math.pow(1-t, 3) * points[0].x + 
                    3 * Math.pow(1-t, 2) * t * points[1].x + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].x + 
                    Math.pow(t, 3) * points[3].x;
            const y = Math.pow(1-t, 3) * points[0].y + 
                    3 * Math.pow(1-t, 2) * t * points[1].y + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].y + 
                    Math.pow(t, 3) * points[3].y;
            clipPoints.push(`${x - startX + 30}px ${y - startY}px`);
          }
          
          gameBoard.appendChild(pathElement);
        }
      });
    }

    // Add terrain elements (trees, rocks, etc.)
    function addTerrainElements() {
      const terrainTypes = ['üå≥', 'üå≤', 'ü™®', 'üèöÔ∏è'];
      const forbiddenAreas = [];
      
      // Add path areas to forbidden zones
      pathSegments.forEach(segment => {
        if (segment.type === 'curved') {
          segment.points.forEach(point => {
            forbiddenAreas.push({
              x: point.x - 40,
              y: point.y - 40,
              width: 80,
              height: 80
            });
          });
        }
      });
      
      // Add 20 random terrain elements
      for (let i = 0; i < 20; i++) {
        const x = Math.floor(Math.random() * 700) + 50;
        const y = Math.floor(Math.random() * 400) + 50;
        
        // Check if position conflicts with forbidden areas
        const isConflict = forbiddenAreas.some(area => 
          x >= area.x && x <= area.x + area.width && 
          y >= area.y && y <= area.y + area.height
        );
        
        if (!isConflict) {
          const terrainElement = document.createElement('div');
          terrainElement.className = 'terrain tree';
          terrainElement.textContent = terrainTypes[Math.floor(Math.random() * terrainTypes.length)];
          terrainElement.style.left = `${x}px`;
          terrainElement.style.top = `${y}px`;
          gameBoard.appendChild(terrainElement);
          
          // Add to forbidden areas for future elements
          forbiddenAreas.push({ x: x - 40, y: y - 40, width: 80, height: 80 });
          gameState.terrainElements.push(terrainElement);
        }
      }
    }

    // Initialize the game
    function initGame() {
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
      
      // Set up difficulty selection
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
          this.classList.add('selected');
          gameState.difficulty = this.getAttribute('data-difficulty');
        });
      });
      
      // Event listener for tower placement
      gameBoard.addEventListener('click', function(event) {
        if (gameState.selectedTowerType) {
          const rect = gameBoard.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          placeTower(x, y);
        }
      });
    }

    // Optimized game loop
    function gameLoop(timestamp) {
      if (!gameState.lastFrameTime) {
        gameState.lastFrameTime = timestamp;
      }
      
      const deltaTime = timestamp - gameState.lastFrameTime;
      gameState.lastFrameTime = timestamp;
      
      if (!gameState.gameOver && !gameState.victory) {
        // Use frame counter to stagger calculations
        gameState.frameCounter++;
        
        // Always update enemy positions every frame
        moveEnemies(deltaTime);
        updateBullets(deltaTime);
        
        // Stagger more expensive operations
        if (gameState.frameCounter % 2 === 0) {
          checkTowerFiring(deltaTime);
        }
        
        if (gameState.frameCounter % 5 === 0) {
          checkWaveStatus();
          checkTowerReloading();
        }
        
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    // Optimized enemy movement along curved path
    function moveEnemies(deltaTime) {
      const enemiesToRemove = [];
      
      gameState.enemies.forEach(enemy => {
        if (enemy.pathIndex >= path.length - 1) {
          // Enemy reached the end
          gameState.lives -= enemy.damage;
          updateInfoPanel();
          enemiesToRemove.push(enemy);
          
          // Check if game over
          if (gameState.lives <= 0) {
            endGame(false);
          }
          return;
        }
        
        // Calculate movement along path
        const speedFactor = enemy.speed * (deltaTime / 16) * gameState.enemySpeedMultiplier;
        enemy.pathProgress += speedFactor;
        
        while (enemy.pathProgress >= 1 && enemy.pathIndex < path.length - 1) {
          enemy.pathProgress -= 1;
          enemy.pathIndex++;
        }
        
        // Interpolate position between current and next path point
        const currentPoint = path[enemy.pathIndex];
        const nextIndex = Math.min(enemy.pathIndex + 1, path.length - 1);
        const nextPoint = path[nextIndex];
        
        enemy.x = currentPoint.x + (nextPoint.x - currentPoint.x) * enemy.pathProgress;
        enemy.y = currentPoint.y + (nextPoint.y - currentPoint.y) * enemy.pathProgress;
        
        // Update visual position
        enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
        enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
      });
      
      // Remove enemies
      enemiesToRemove.forEach(enemy => removeEnemy(enemy));
    }

    // Tower firing with efficiency improvements
    function checkTowerFiring(deltaTime) {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        // Skip if reloading or no ammo
        if (tower.reloading || tower.ammo <= 0) return;
        if (currentTime - tower.lastFired < tower.fireRate) return;
        
        const target = findTarget(tower);
        if (target) {
          fireTower(tower, target);
          tower.lastFired = currentTime;
          tower.ammo--;
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = `${(tower.ammo / tower.maxAmmo) * 100}%`;
          }
          
          // Start reloading if out of ammo
          if (tower.ammo <= 0) {
            startReloading(tower);
          }
        }
      });
    }

    // Batch check tower reloading status
    function checkTowerReloading() {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        if (tower.reloading && currentTime - tower.reloadStart >= tower.reloadTime) {
          tower.reloading = false;
          tower.ammo = tower.maxAmmo;
          tower.element.style.opacity = '1';
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = '100%';
          }
        }
      });
    }

    // Optimized bullet movement and collision detection
    function updateBullets(deltaTime) {
      const bulletsToRemove = [];
      
      gameState.bullets.forEach(bullet => {
        // Move bullet
        const moveSpeed = 0.4 * deltaTime;
        const dx = bullet.targetX - bullet.x;
        const dy = bullet.targetY - bullet.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          bullet.x += (dx / distance) * moveSpeed;
          bullet.y += (dy / distance) * moveSpeed;
          bullet.distance += moveSpeed;
        }
        
        bullet.element.style.left = `${bullet.x - 3}px`;
        bullet.element.style.top = `${bullet.y - 3}px`;
        
        // Artillery explosion
        if (bullet.type === 'artillery' && bullet.distance >= bullet.maxDistance * 0.9) {
          createExplosion(bullet.targetX, bullet.targetY, bullet.damage);
          bulletsToRemove.push(bullet);
          return;
        }
        
        // Check for hits using spatial partitioning
        let hitEnemy = null;
        for (let i = 0; i < gameState.enemies.length && !hitEnemy; i++) {
          const enemy = gameState.enemies[i];
          const hitDx = enemy.x - bullet.x;
          const hitDy = enemy.y - bullet.y;
          const hitDistance = Math.sqrt(hitDx * hitDx + hitDy * hitDy);
          
          if (hitDistance < 15) {
            hitEnemy = enemy;
            damageEnemy(enemy, bullet.damage);
          }
        }
        
        // Remove bullet if hit or out of range
        if (hitEnemy || bullet.distance > bullet.maxDistance) {
          bulletsToRemove.push(bullet);
        }
      });
      
      // Batch remove bullets
      bulletsToRemove.forEach(bullet => {
        bullet.element.remove();
        const index = gameState.bullets.indexOf(bullet);
        if (index !== -1) {
          gameState.bullets.splice(index, 1);
        }
      });
    }

    // Helper functions (tower selection, enemy creation, etc.)
    function selectTower(type) {
      closeUpgradePanel();
      document.querySelectorAll('.tower-option').forEach(o => o.classList.remove('selected'));
      document.querySelector(`.tower-option[data-type="${type}"]`).classList.add('selected');
      gameState.selectedTowerType = type;
    }

    function placeTower(x, y) {
      if (isOnPath(x, y) || isTowerConflict(x, y)) return;
      
      const towerType = towerTypes[gameState.selectedTowerType];
      if (gameState.resources < towerType.cost) return;
      
      gameState.resources -= towerType.cost;
      updateInfoPanel();
      createTower(x, y, gameState.selectedTowerType);
    }

    function isOnPath(x, y) {
      // Check distance to path points
      for (let i = 0; i < path.length; i++) {
        const dx = path[i].x - x;
        const dy = path[i].y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 30) return true;
      }
      return false;
    }

    function isTowerConflict(x, y) {
      return gameState.towers.some(tower => {
        const dx = tower.x - x;
        const dy = tower.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 40;
      });
    }

    // More efficient tower creation
    function createTower(x, y, type) {
      const tower = document.createElement('div');
      tower.className = `tower ${type}`;
      tower.textContent = towerTypes[type].icon;
      
      // Create range indicator
      const range = document.createElement('div');
      range.className = 'tower-range';
      range.style.width = `${towerTypes[type].range * 2}px`;
      range.style.height = `${towerTypes[type].range * 2}px`;
      range.style.left = `-${towerTypes[type].range - 20}px`;
      range.style.top = `-${towerTypes[type].range - 20}px`;
      tower.appendChild(range);
      
      // Create ammo bar
      const ammoBar = document.createElement('div');
      ammoBar.className = 'ammo-bar';
      const ammoFill = document.createElement('div');
      ammoFill.className = 'ammo-fill';
      ammoBar.appendChild(ammoFill);
      tower.appendChild(ammoBar);
      
      // Position tower
      tower.style.left = `${x - 20}px`;
      tower.style.top = `${y - 20}px`;
      gameBoard.appendChild(tower);
      
      // Create tower object with all properties
      const towerObj = {
        x, y, type, element: tower, lastFired: 0,
        damage: towerTypes[type].damage,
        range: towerTypes[type].range,
        fireRate: towerTypes[type].fireRate,
        targets: towerTypes[type].targets,
        ammo: towerTypes[type].ammo,
        maxAmmo: towerTypes[type].maxAmmo,
        reloadTime: towerTypes[type].reloadTime,
        reloading: false,
        ammoBar: ammoFill,
        level: { damage: 1, range: 1, rate: 1 }
      };
      
      if (type === 'artillery') {
        towerObj.splash = towerTypes[type].splash;
      }
      
      // Add events
      tower.addEventListener('mouseover', () => range.style.display = 'block');
      tower.addEventListener('mouseout', () => range.style.display = 'none');
      tower.addEventListener('click', (e) => {
        e.stopPropagation();
        selectTowerForUpgrade(towerObj);
      });
      
      gameState.towers.push(towerObj);
    }

    // More efficient target finding using spatial partitioning
    function findTarget(tower) {
      let closestEnemy = null;
      let closestDistance = Infinity;
      
      // First pass: filter by type
      const potentialTargets = gameState.enemies.filter(enemy => tower.targets.includes(enemy.type));
      
      // Second pass: find closest in range
      potentialTargets.forEach(enemy => {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= tower.range && distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      return closestEnemy;
    }

    // Tower upgrade panel
    function selectTowerForUpgrade(tower) {
      gameState.selectedTower = tower;
      
      document.getElementById('upgrade-damage').textContent = `Damage +25% ($${30 * tower.level.damage})`;
      document.getElementById('upgrade-range').textContent = `Range +15% ($${25 * tower.level.range})`;
      document.getElementById('upgrade-rate').textContent = `Fire Rate +20% ($${35 * tower.level.rate})`;
      
      document.getElementById('upgrade-damage').classList.toggle('disabled', gameState.resources < 30 * tower.level.damage);
      document.getElementById('upgrade-range').classList.toggle('disabled', gameState.resources < 25 * tower.level.range);
      document.getElementById('upgrade-rate').classList.toggle('disabled', gameState.resources < 35 * tower.level.rate);
      
      const upgradePanel = document.getElementById('upgrade-panel');
      upgradePanel.style.left = `${tower.x + 30}px`;
      upgradePanel.style.top = `${tower.y - 50}px`;
      upgradePanel.style.display = 'block';
    }

    function closeUpgradePanel() {
      document.getElementById('upgrade-panel').style.display = 'none';
      gameState.selectedTower = null;
    }

    function upgradeTower(upgradeType) {
      if (!gameState.selectedTower) return;
      
      const tower = gameState.selectedTower;
      let cost = 0;
      
      switch (upgradeType) {
        case 'damage':
          cost = 30 * tower.level.damage;
          if (gameState.resources >= cost) {
            tower.damage *= 1.25;
            tower.level.damage++;
          }
          break;
        case 'range':
          cost = 25 * tower.level.range;
          if (gameState.resources >= cost) {
            tower.range *= 1.15;
            tower.level.range++;
            
            const rangeIndicator = tower.element.querySelector('.tower-range');
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
          break;
        case 'rate':
          cost = 35 * tower.level.rate;
          if (gameState.resources >= cost) {
            tower.fireRate *= 0.8;
            tower.level.rate++;
          }
          break;
      }
      
      if (cost && gameState.resources >= cost) {
        gameState.resources -= cost;
        updateInfoPanel();
        
        tower.element.style.transform = 'scale(1.3)';
        setTimeout(() => tower.element.style.transform = 'scale(1)', 300);
        
        closeUpgradePanel();
        selectTowerForUpgrade(tower);
      }
    }

    // Wave management with improved efficiency
    function startWave() {
      if (gameState.waveInProgress) return;
      
      gameState.waveInProgress = true;
      startButton.disabled = true;
      startButton.textContent = 'Wave in Progress';
      
      const waveDefinition = waveDefinitions[gameState.currentWave];
      spawnEnemies(waveDefinition);
      
      if (gameState.animationFrameId === null) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function spawnEnemies(waveDefinition) {
      const enemiesToSpawn = [];
      const spawnDelay = difficultySettings[gameState.difficulty].waveSpawnDelay;
      
      // Add normal enemies
      Object.entries(waveDefinition).forEach(([type, count]) => {
        if (type !== 'elites') {
          for (let i = 0; i < count; i++) {
            enemiesToSpawn.push(type);
          }
        }
      });
      
      // Add elite enemies
      if (waveDefinition.elites) {
        waveDefinition.elites.forEach(eliteType => {
          const eliteCount = Math.floor(Math.random() * 2) + 2;
          for (let i = 0; i < eliteCount; i++) {
            enemiesToSpawn.push(`elite_${eliteType}`);
          }
        });
      }
      
      // Shuffle and spawn
      shuffleArray(enemiesToSpawn);
      
      enemiesToSpawn.forEach((enemyType, index) => {
        setTimeout(() => {
          if (!gameState.gameOver && !gameState.victory) {
            if (enemyType.includes('elite_')) {
              createEnemy(enemyType.split('_')[1], true);
            } else {
              createEnemy(enemyType, false);
            }
          }
        }, index * spawnDelay);
      });
    }

    // Core game functions (unchanged but streamlined)
    function createEnemy(type, isElite) {
      const enemy = document.createElement('div');
      enemy.className = `enemy ${type}${isElite ? ' elite' : ''}`;
      enemy.textContent = enemyTypes[type].icon;
      
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      const healthFill = document.createElement('div');
      healthFill.className = 'health-fill';
      healthBar.appendChild(healthFill);
      enemy.appendChild(healthBar);
      
      gameBoard.appendChild(enemy);
      
      // Apply difficulty and elite modifiers
      const difficultyMod = difficultySettings[gameState.difficulty];
      let health = enemyTypes[type].health * difficultyMod.enemyHealthMultiplier;
      let speed = enemyTypes[type].speed * difficultyMod.enemySpeedMultiplier;
      let worth = Math.floor(enemyTypes[type].worth * difficultyMod.resourceMultiplier);
      let scoreValue = enemyTypes[type].scoreValue;
      
      if (isElite) {
        health *= eliteModifiers.health;
        speed *= eliteModifiers.speed;
        worth *= eliteModifiers.worth;
        scoreValue *= eliteModifiers.scoreValue;
      }
      
      const enemyObj = {
        id: Math.random().toString(36).substr(2, 9),
        x: path[0].x, y: path[0].y,
        type, element: enemy,
        pathIndex: 0, pathProgress: 0,
        health, maxHealth: health, speed, worth,
        damage: enemyTypes[type].damage,
        scoreValue, isElite
      };
      
      enemy.style.left = `${enemyObj.x - enemy.offsetWidth/2}px`;
      enemy.style.top = `${enemyObj.y - enemy.offsetHeight/2}px`;
      
      gameState.enemies.push(enemyObj);
    }

    function fireTower(tower, target) {
      const bullet = document.createElement('div');
      bullet.className = `bullet ${tower.type}`;
      gameBoard.appendChild(bullet);
      
      const bulletObj = {
        x: tower.x, y: tower.y,
        targetX: target.x, targetY: target.y,
        element: bullet, damage: tower.damage,
        distance: 0, maxDistance: tower.range * 1.2,
        type: tower.type
      };
      
      bullet.style.left = `${bulletObj.x - 3}px`;
      bullet.style.top = `${bulletObj.y - 3}px`;
      
      gameState.bullets.push(bulletObj);
    }

    function startReloading(tower) {
      tower.reloading = true;
      tower.reloadStart = Date.now();
      tower.element.style.opacity = '0.7';
    }

    function createExplosion(x, y, damage) {
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = `${x}px`;
      explosion.style.top = `${y}px`;
      gameBoard.appendChild(explosion);
      
      gameState.enemies.forEach(enemy => {
        const dx = enemy.x - x;
        const dy = enemy.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= 60) {
          const damageMultiplier = 1 - (distance / 60);
          const splashDamage = Math.round(damage * damageMultiplier);
          if (splashDamage > 0) {
            damageEnemy(enemy, splashDamage);
          }
        }
      });
      
      setTimeout(() => explosion.remove(), 500);
    }

    function damageEnemy(enemy, damage) {
      enemy.health -= damage;
      
      const healthFill = enemy.element.querySelector('.health-fill');
      healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
      
      if (enemy.health <= 0) {
        gameState.resources += enemy.worth;
        gameState.score += enemy.scoreValue;
        updateInfoPanel();
        removeEnemy(enemy);
      }
    }

    function removeEnemy(enemy) {
      enemy.element.remove();
      const index = gameState.enemies.findIndex(e => e.id === enemy.id);
      if (index !== -1) {
        gameState.enemies.splice(index, 1);
      }
    }

    function checkWaveStatus() {
      if (gameState.waveInProgress && gameState.enemies.length === 0) {
        gameState.waveInProgress = false;
        gameState.currentWave++;
        
        if (gameState.currentWave >= gameState.maxWaves) {
          endGame(true);
        } else {
          startButton.disabled = false;
          startButton.textContent = `Start Wave ${gameState.currentWave + 1}`;
        }
        
        updateInfoPanel();
      }
    }

    function updateInfoPanel() {
      waveInfoElement.textContent = `Wave: ${gameState.currentWave}/${gameState.maxWaves}`;
      resourcesElement.textContent = `Resources: ${Math.floor(gameState.resources)}`;
      livesElement.textContent = `Base Health: ${gameState.lives}/20`;
      scoreElement.textContent = `Score: ${gameState.score}`;
    }

    function endGame(victory) {
      if (victory) {
        gameState.victory = true;
        levelCompletePanel.style.display = 'block';
        victoryScoreElement.textContent = gameState.score;
      } else {
        gameState.gameOver = true;
        gameOverPanel.style.display = 'block';
        finalScoreElement.textContent = gameState.score;
      }
      
      closeUpgradePanel();
      cancelAnimationFrame(gameState.animationFrameId);
    }

    function restartGame() {
      // Clear game elements
      gameState.enemies.forEach(enemy => enemy.element.remove());
      gameState.towers.forEach(tower => tower.element.remove());
      gameState.bullets.forEach(bullet => bullet.element.remove());
      gameState.terrainElements.forEach(element => element.remove());
      gameState.terrainElements = [];
      
      // Reset game state
      Object.assign(gameState, {
        resources: 150, lives: 20, currentWave: 0, waveInProgress: false,
        gameOver: false, victory: false, selectedTowerType: null, selectedTower: null,
        towers: [], enemies: [], bullets: [], animationFrameId: null,
        score: 0, lastFrameTime: 0, frameCounter: 0, enemySpeedMultiplier: 0.4
      });
      
      // Reset UI
      startButton.disabled = false;
      startButton.textContent = 'Start Wave 1';
      gameOverPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      upgradePanel.style.display = 'none';
      document.querySelectorAll('.tower-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      // Reinitialize game
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
    }

    // Utility functions
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Initialize the game
    initGame();
  </script>
</body>
</html>