<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WWII Tower Defense - Improved</title>
  <style>
    body { margin: 0; padding: 0; font-family: 'Courier New', monospace; background-color: #222; color: #fff; }
    #game-container { position: relative; width: 800px; height: 500px; margin: 20px auto; overflow: hidden; box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); }
    #game-board { position: relative; width: 100%; height: 100%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="%233d4c2e" /><rect x="0" y="0" width="50" height="50" fill="%233a4929" opacity="0.4" /><rect x="50" y="50" width="50" height="50" fill="%233a4929" opacity="0.4" /></svg>'); }
    
    /* Terrain elements */
    .terrain { position: absolute; pointer-events: none; }
    .tree { width: 30px; height: 30px; font-size: 24px; text-align: center; }
    .rock { width: 20px; height: 20px; background-color: #777; border-radius: 5px; opacity: 0.8; }
    
    /* Strategic terrain types */
    .terrain.hill { 
      background: radial-gradient(circle, rgba(139, 125, 57, 0.3) 0%, rgba(139, 125, 57, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
    }
    .terrain.forest { 
      background: radial-gradient(circle, rgba(58, 73, 41, 0.4) 0%, rgba(58, 73, 41, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
    }
    .terrain.resource { 
      background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
      animation: resourcePulse 2s infinite;
    }
    @keyframes resourcePulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0.1); }
      100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
    }
    .terrain.decoration {
      cursor: default;
    }
    
    /* Terrain bonus indicators */
    .terrain-bonus {
      position: absolute;
      bottom: -5px;
      right: -5px;
      background-color: rgba(255, 204, 0, 0.8);
      color: #000;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
      display: none;
    }
    
    .terrain:hover .terrain-bonus {
      display: block;
    }
    
    /* Improved path styling */
    .path { position: absolute; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60"><rect width="60" height="60" fill="%238B4513" opacity="0.6" /><line x1="0" y1="20" x2="60" y2="20" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /><line x1="0" y1="40" x2="60" y2="40" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /></svg>'); pointer-events: none; }
    
    /* Keep all other styles from original game */
    #info-panel { width: 800px; margin: 0 auto; display: flex; justify-content: space-between; padding: 10px; background-color: #3a3a3a; border: 3px solid #8b7d39; border-top: none; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
    #tower-selection { display: flex; gap: 10px; }
    .tower-option { width: 60px; height: 60px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px solid #777; border-radius: 5px; background-color: #444; transition: all 0.2s; }
    .tower-option:hover { background-color: #555; transform: translateY(-3px); }
    .tower-option.selected { border-color: #ffcc00; box-shadow: 0 0 10px #ffcc00; }
    .tower-icon { font-size: 24px; margin-bottom: 5px; }
    .tower-cost { font-size: 12px; font-weight: bold; color: #ffcc00; }
    .tower { 
      position: absolute; 
      width: 40px; 
      height: 40px; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      cursor: pointer; 
      z-index: 10; 
      font-size: 20px; 
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      transition: transform 0.1s ease-out;
      overflow: visible;
    }
    .tower:hover { box-shadow: 0 0 8px 3px #ffcc00; }
    
    /* Tower turret (for rotation animations) */
    .tower-turret {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease-out;
      transform-origin: center center;
    }
    
    /* Tower barrel (extends from turret) */
    .tower-barrel {
      position: absolute;
      background-color: #333;
      border-radius: 2px;
      transform-origin: left center;
      transition: transform 0.1s ease-out;
      z-index: -1;
    }
    
    /* Different barrel styles for each tower type */
    .tower.mg .tower-barrel {
      width: 25px;
      height: 3px;
      right: -15px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #666;
    }
    
    .tower.artillery .tower-barrel {
      width: 30px;
      height: 6px;
      right: -20px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #4a7b49;
    }
    
    .tower.aa .tower-barrel {
      width: 20px;
      height: 4px;
      right: -12px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #3a6da3;
    }
    
    .tower.sniper .tower-barrel {
      width: 35px;
      height: 2px;
      right: -22px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #8a4f3b;
    }
    
    /* Recoil animation */
    @keyframes recoilAnimation {
      0% { transform: scale(1); }
      20% { transform: scale(0.95) translateX(-2px); }
      100% { transform: scale(1) translateX(0); }
    }
    
    @keyframes barrelRecoil {
      0% { transform: translateY(-50%) scaleX(1); }
      30% { transform: translateY(-50%) scaleX(0.8); }
      100% { transform: translateY(-50%) scaleX(1); }
    }
    
    /* Firing animation classes */
    .tower.firing {
      animation: recoilAnimation 0.2s ease-out;
    }
    
    .tower.firing .tower-barrel {
      animation: barrelRecoil 0.2s ease-out;
    }
    
    /* Rotating animation for radar */
    .tower.radar .tower-turret {
      animation: radarRotate 4s linear infinite;
    }
    
    @keyframes radarRotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Idle animation for active towers */
    .tower.active {
      animation: towerIdle 3s ease-in-out infinite;
    }
    
    @keyframes towerIdle {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Dynamic Lighting Effects */
    .light-effect {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      z-index: 12;
      mix-blend-mode: screen;
    }
    
    /* Explosion lighting */
    .light-effect.explosion-light {
      background: radial-gradient(circle, 
        rgba(255, 165, 0, 0.8) 0%, 
        rgba(255, 69, 0, 0.6) 30%, 
        rgba(255, 140, 0, 0.3) 60%, 
        transparent 100%);
      animation: explosionLight 0.8s ease-out forwards;
    }
    
    @keyframes explosionLight {
      0% { 
        transform: scale(0.2); 
        opacity: 1; 
      }
      30% { 
        transform: scale(1.5); 
        opacity: 0.9; 
      }
      100% { 
        transform: scale(3); 
        opacity: 0; 
      }
    }
    
    /* Muzzle flash lighting */
    .light-effect.muzzle-light {
      background: radial-gradient(circle, 
        rgba(255, 255, 100, 0.7) 0%, 
        rgba(255, 200, 50, 0.4) 50%, 
        transparent 100%);
      animation: muzzleLight 0.15s ease-out forwards;
    }
    
    @keyframes muzzleLight {
      0% { 
        transform: scale(0.5); 
        opacity: 1; 
      }
      100% { 
        transform: scale(2); 
        opacity: 0; 
      }
    }
    
    /* Artillery shell light trail */
    .light-effect.shell-light {
      background: radial-gradient(circle, 
        rgba(255, 140, 0, 0.6) 0%, 
        rgba(255, 69, 0, 0.3) 50%, 
        transparent 100%);
      animation: shellLight 0.4s ease-out forwards;
    }
    
    @keyframes shellLight {
      0% { 
        transform: scale(0.8); 
        opacity: 0.8; 
      }
      100% { 
        transform: scale(1.5); 
        opacity: 0; 
      }
    }
    
    /* Ambient lighting for active towers */
    .tower.active::after {
      content: '';
      position: absolute;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, 
        rgba(255, 215, 0, 0.1) 0%, 
        rgba(255, 215, 0, 0.05) 50%, 
        transparent 100%);
      border-radius: 50%;
      top: -10px;
      left: -10px;
      pointer-events: none;
      z-index: -1;
      animation: ambientGlow 2s ease-in-out infinite;
    }
    
    @keyframes ambientGlow {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }
    
    /* Environmental lighting effects */
    .light-effect.resource-glow {
      background: radial-gradient(circle, 
        rgba(255, 215, 0, 0.2) 0%, 
        rgba(255, 215, 0, 0.1) 50%, 
        transparent 100%);
      animation: resourceGlow 3s ease-in-out infinite;
    }
    
    @keyframes resourceGlow {
      0%, 100% { opacity: 0.4; transform: scale(0.8); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    /* Screen overlay for dramatic lighting moments */
    .screen-flash {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      pointer-events: none;
      z-index: 20;
      animation: screenFlash 0.1s ease-out forwards;
    }
    
    @keyframes screenFlash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Weather System */
    .weather-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 18;
    }
    
    /* Rain Effect */
    .rain-drop {
      position: absolute;
      width: 2px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(173, 216, 230, 0.8), rgba(173, 216, 230, 0.2));
      border-radius: 1px;
      animation: rainFall linear infinite;
    }
    
    @keyframes rainFall {
      to {
        transform: translateY(500px);
        opacity: 0;
      }
    }
    
    /* Fog Effect */
    .fog-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 120%;
      height: 120%;
      background: radial-gradient(ellipse at center, 
        rgba(220, 220, 220, 0.3) 0%, 
        rgba(200, 200, 200, 0.6) 30%, 
        rgba(180, 180, 180, 0.4) 70%, 
        transparent 100%);
      animation: fogDrift 20s ease-in-out infinite;
    }
    
    @keyframes fogDrift {
      0%, 100% { 
        transform: translateX(-10%) translateY(-10%); 
        opacity: 0.6; 
      }
      50% { 
        transform: translateX(10%) translateY(10%); 
        opacity: 0.8; 
      }
    }
    
    /* Snow Effect */
    .snow-flake {
      position: absolute;
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
      opacity: 0.8;
      animation: snowFall linear infinite;
    }
    
    @keyframes snowFall {
      to {
        transform: translateY(500px) translateX(50px);
        opacity: 0;
      }
    }
    
    /* Weather visibility effects */
    .weather-reduced-visibility {
      filter: blur(1px) contrast(0.8);
    }
    
    .weather-heavy-reduced-visibility {
      filter: blur(2px) contrast(0.6) brightness(0.8);
    }
    
    /* Weather UI indicator */
    .weather-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      display: none;
      z-index: 25;
    }
    .tower.mg { background-color: #3a3a3a; border: 2px solid #6e6e6e; }
    .tower.artillery { background-color: #2d572c; border: 2px solid #4a7b49; }
    .tower.aa { background-color: #1a3e5c; border: 2px solid #3a6da3; }
    .tower.sniper { background-color: #5c2b1a; border: 2px solid #8a4f3b; }
    .tower.engineer { background-color: #8b4513; border: 2px solid #d2691e; }
    .tower.radar { background-color: #4b0082; border: 2px solid #9370db; }
    .tower.command { background-color: #556b2f; border: 2px solid #9acd32; }
    .tower-range { position: absolute; border-radius: 50%; background-color: rgba(255, 240, 130, 0.15); border: 1px dashed rgba(255, 204, 0, 0.3); pointer-events: none; z-index: 5; display: none; }
    .bullet { position: absolute; width: 6px; height: 6px; border-radius: 50%; z-index: 8; }
    .bullet.mg { background-color: #ffcc00; }
    .bullet.artillery { background-color: #ff6600; width: 8px; height: 8px; }
    .bullet.aa { background-color: #00ccff; }
    .bullet.sniper { background-color: #ff0000; width: 4px; height: 10px; }
    .explosion { position: absolute; width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle, rgba(255,102,0,0.8) 0%, rgba(255,153,0,0.6) 40%, rgba(255,204,0,0.2) 70%, rgba(255,204,0,0) 100%); z-index: 8; transform: translate(-50%, -50%); animation: explode 0.5s forwards; }
    @keyframes explode { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }
    .enemy { position: absolute; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 9; border-radius: 3px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
    .enemy.infantry { background-color: #8b0000; border: 1px solid #ff0000; }
    .enemy.tank { background-color: #b22222; width: 35px; height: 35px; border: 1px solid #ff3333; }
    .enemy.heavytank { background-color: #8b4500; width: 40px; height: 40px; border: 1px solid #ff7700; }
    .enemy.aircraft { background-color: #4b0082; border: 1px solid #9370db; }
    .enemy.elite { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    .health-bar { position: absolute; width: 30px; height: 4px; background-color: #333; top: -8px; left: 0; border-radius: 2px; overflow: hidden; }
    .health-fill { height: 100%; background-color: #32cd32; width: 100%; transition: width 0.2s; }
    #start-button { padding: 8px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
    #start-button:hover { background-color: #3e8e41; }
    #start-button:disabled { background-color: #cccccc; cursor: not-allowed; }
    #wave-info, #resources, #lives, #score-display { font-size: 16px; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; margin-right: 10px; }
    #wave-info { color: #ffcc00; }
    #resources { color: #32cd32; }
    #lives { color: #ff6666; }
    #score-display { color: #66ccff; }
    #game-over, #level-complete { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 10px; text-align: center; display: none; z-index: 100; border: 3px solid #8b7d39; box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); width: 300px; }
    .game-over-title { color: #ff6666; margin-top: 0; font-size: 28px; }
    .victory-title { color: #32cd32; margin-top: 0; font-size: 28px; }
    .final-score { font-size: 20px; margin: 15px 0; color: #ffcc00; }
    button.restart { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 15px; cursor: pointer; font-size: 16px; }
    button.restart:hover { background-color: #3e8e41; }
    #instructions { width: 800px; margin: 10px auto; background-color: #3a3a3a; padding: 15px; border: 3px solid #8b7d39; border-radius: 5px; margin-bottom: 20px; }
    .difficulty-selection { display: flex; gap: 10px; margin-top: 10px; }
    .difficulty-btn { padding: 8px 15px; background-color: #555; border: none; color: white; border-radius: 5px; cursor: pointer; flex: 1; }
    .difficulty-btn:hover { background-color: #666; }
    .difficulty-btn.selected { background-color: #4CAF50; font-weight: bold; }
    .upgrade-panel { display: none; position: absolute; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #ffcc00; border-radius: 5px; padding: 10px; z-index: 20; width: 150px; }
    .upgrade-option { margin-bottom: 8px; cursor: pointer; padding: 5px; background-color: #444; border-radius: 3px; }
    .upgrade-option:hover { background-color: #555; }
    .upgrade-option.disabled { opacity: 0.5; cursor: not-allowed; }
    .close-panel { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; font-size: 14px; }
    .ammo-bar { position: absolute; bottom: -8px; left: 0; width: 30px; height: 3px; background-color: #333; border-radius: 1px; overflow: hidden; }
    .ammo-fill { height: 100%; background-color: #ffaa00; width: 100%; }
    
    /* Special structures and effects */
    .wall { position: absolute; width: 20px; height: 20px; background-color: #8b4513; border: 1px solid #654321; z-index: 8; }
    .mine { position: absolute; width: 15px; height: 15px; background-color: #696969; border: 1px solid #2f4f4f; border-radius: 50%; z-index: 8; cursor: pointer; }
    .mine:hover { background-color: #ff4500; }
    .supply-convoy { position: absolute; width: 25px; height: 25px; background-color: #4CAF50; border: 2px solid #2E7D32; z-index: 9; font-size: 16px; display: flex; align-items: center; justify-content: center; }
    
    /* Radar detection effects */
    .radar-sweep { position: absolute; border-radius: 50%; border: 2px solid rgba(75, 0, 130, 0.6); animation: radarSweep 3s infinite; pointer-events: none; z-index: 6; }
    @keyframes radarSweep { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
    
    /* Command post aura */
    .command-aura { position: absolute; border-radius: 50%; background-color: rgba(154, 205, 50, 0.1); border: 1px dashed rgba(154, 205, 50, 0.3); pointer-events: none; z-index: 5; }
    
    /* Special action buttons */
    .action-buttons { position: absolute; display: none; z-index: 25; }
    .action-btn { padding: 4px 8px; margin: 2px; background-color: #444; color: white; border: 1px solid #666; border-radius: 3px; font-size: 12px; cursor: pointer; }
    .action-btn:hover { background-color: #555; }
    .action-btn.disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Particle System */
    .particle { 
      position: absolute; 
      pointer-events: none; 
      z-index: 15; 
      border-radius: 50%; 
    }
    
    /* Explosion particles */
    .particle.explosion { 
      background: radial-gradient(circle, #ff6600 0%, #ff9900 50%, #ffcc00 100%);
      animation: explodeParticle 0.8s ease-out forwards;
    }
    
    @keyframes explodeParticle {
      0% { 
        transform: scale(1) rotate(0deg); 
        opacity: 1; 
      }
      100% { 
        transform: scale(0.1) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    /* Muzzle flash particles */
    .particle.muzzle { 
      background: radial-gradient(circle, #ffff00 0%, #ff6600 50%, transparent 100%);
      animation: muzzleFlash 0.2s ease-out forwards;
    }
    
    @keyframes muzzleFlash {
      0% { 
        transform: scale(0.5); 
        opacity: 1; 
      }
      100% { 
        transform: scale(2); 
        opacity: 0; 
      }
    }
    
    /* Smoke particles */
    .particle.smoke { 
      background: radial-gradient(circle, rgba(80, 80, 80, 0.8) 0%, rgba(120, 120, 120, 0.4) 50%, transparent 100%);
      animation: smokeRise 2s ease-out forwards;
    }
    
    @keyframes smokeRise {
      0% { 
        transform: scale(0.5) translateY(0); 
        opacity: 0.8; 
      }
      100% { 
        transform: scale(2) translateY(-50px); 
        opacity: 0; 
      }
    }
    
    /* Bullet trail particles */
    .particle.trail { 
      background: linear-gradient(90deg, #ffcc00 0%, transparent 100%);
      border-radius: 50%;
      animation: trailFade 0.3s ease-out forwards;
    }
    
    @keyframes trailFade {
      0% { 
        opacity: 0.8; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.2); 
      }
    }
    
    /* Spark particles */
    .particle.spark { 
      background: #ffff00;
      animation: sparkFly 0.5s ease-out forwards;
    }
    
    @keyframes sparkFly {
      0% { 
        opacity: 1; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1); 
      }
    }
    
    /* Artillery shell particles */
    .particle.shell { 
      background: #8B4513;
      border-radius: 20%;
      animation: shellFly 0.4s ease-out forwards;
    }
    
    @keyframes shellFly {
      0% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.3) rotate(180deg); 
      }
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2 style="margin-top: 0;">WWII Tower Defense - Procedural Maps</h2>
    <p>Select a tower, place it on strategic terrain, and defend against waves of enemies!</p>
    <p><strong>Combat Towers:</strong> Machine Gun (üë®‚Äçü¶Ø) - infantry, Artillery (üí£) - area damage, Anti-Air (‚ö°) - aircraft, Sniper (üî≠) - high damage</p>
    <p><strong>Support Towers:</strong> Engineer (üîß) - builds walls/mines, Radar (üì°) - boosts AA range/detection, Command (üèõÔ∏è) - buffs nearby towers (+30% damage)</p>
    <p><strong>Strategic Elements:</strong> Hills (üèîÔ∏è) +25% range, Forests (üå≤) concealment, Resource nodes (üí∞) passive income, Supply convoys (üöõ) bonus resources</p>
    <div class="difficulty-selection">
      <button class="difficulty-btn selected" data-difficulty="normal">Normal</button>
      <button class="difficulty-btn" data-difficulty="hard">Hard</button>
      <button class="difficulty-btn" data-difficulty="veteran">Veteran</button>
      <button id="new-map-btn" style="padding: 8px 15px; background-color: #ff6600; border: none; color: white; border-radius: 5px; cursor: pointer; margin-left: 10px;" onclick="generateNewMap()">New Map</button>
    </div>
  </div>
  
  <div id="game-container">
    <div id="game-board">
      <!-- Paths will be created dynamically -->
      <div class="weather-overlay" id="weather-overlay"></div>
      <div class="weather-indicator" id="weather-indicator">Clear</div>
    </div>
    <div id="game-over">
      <h2 class="game-over-title">Game Over!</h2>
      <p>Your base was overrun!</p>
      <div class="final-score">Final Score: <span id="final-score">0</span></div>
      <button class="restart" onclick="restartGame()">Try Again</button>
    </div>
    <div id="level-complete">
      <h2 class="victory-title">Victory!</h2>
      <p>You successfully defended your position!</p>
      <div class="final-score">Final Score: <span id="victory-score">0</span></div>
      <button class="restart" onclick="restartGame()">Play Again</button>
    </div>
  </div>
  
  <div id="info-panel">
    <div style="display: flex;">
      <div id="wave-info">Wave: 0/12</div>
      <div id="resources">Resources: 150</div>
      <div id="lives">Base Health: 20/20</div>
      <div id="score-display">Score: 0</div>
    </div>
    <div id="tower-selection">
      <div class="tower-option" data-type="mg" onclick="selectTower('mg')">
        <div class="tower-icon">üë®‚Äçü¶Ø</div>
        <div class="tower-cost">$25</div>
      </div>
      <div class="tower-option" data-type="artillery" onclick="selectTower('artillery')">
        <div class="tower-icon">üí£</div>
        <div class="tower-cost">$50</div>
      </div>
      <div class="tower-option" data-type="aa" onclick="selectTower('aa')">
        <div class="tower-icon">‚ö°</div>
        <div class="tower-cost">$40</div>
      </div>
      <div class="tower-option" data-type="sniper" onclick="selectTower('sniper')">
        <div class="tower-icon">üî≠</div>
        <div class="tower-cost">$60</div>
      </div>
      <div class="tower-option" data-type="engineer" onclick="selectTower('engineer')">
        <div class="tower-icon">üîß</div>
        <div class="tower-cost">$45</div>
      </div>
      <div class="tower-option" data-type="radar" onclick="selectTower('radar')">
        <div class="tower-icon">üì°</div>
        <div class="tower-cost">$35</div>
      </div>
      <div class="tower-option" data-type="command" onclick="selectTower('command')">
        <div class="tower-icon">üèõÔ∏è</div>
        <div class="tower-cost">$80</div>
      </div>
    </div>
    <button id="start-button" onclick="startWave()">Start Wave 1</button>
  </div>

  <div class="upgrade-panel" id="upgrade-panel">
    <div class="close-panel" onclick="closeUpgradePanel()">‚úï</div>
    <div class="upgrade-option" id="upgrade-damage" onclick="upgradeTower('damage')">Damage +25% ($30)</div>
    <div class="upgrade-option" id="upgrade-range" onclick="upgradeTower('range')">Range +15% ($25)</div>
    <div class="upgrade-option" id="upgrade-rate" onclick="upgradeTower('rate')">Fire Rate +20% ($35)</div>
  </div>

  <script>
    // Game state
    const gameState = {
      resources: 150, lives: 20, currentWave: 0, maxWaves: 12, waveInProgress: false,
      gameOver: false, victory: false, score: 0, selectedTowerType: null, selectedTower: null,
      towers: [], enemies: [], bullets: [], animationFrameId: null, difficulty: 'normal',
      lastFrameTime: 0, terrainElements: [], frameCounter: 0, enemySpeedMultiplier: 0.025,
      walls: [], mines: [], radarCoverage: false, nextWavePreview: null, supplyConvoys: [],
      lastConvoyTime: 0, particles: [], weather: { type: 'clear', intensity: 0, lastChange: 0 },
      performanceMetrics: {
        enemiesKilled: 0, wavesCompleted: 0, accuracy: 100, efficiency: 100
      }
    };

    // Particle System
    class ParticleSystem {
      static createExplosionParticles(x, y, intensity = 8) {
        // Main explosion particles
        for (let i = 0; i < intensity; i++) {
          const angle = (Math.PI * 2 * i) / intensity;
          const speed = 50 + Math.random() * 30;
          const size = 6 + Math.random() * 8;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            type: 'explosion',
            life: 0.8
          });
        }
        
        // Smoke particles
        for (let i = 0; i < 4; i++) {
          this.createParticle({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 20,
            vy: -20 - Math.random() * 10,
            size: 15 + Math.random() * 10,
            type: 'smoke',
            life: 2
          });
        }
        
        // Sparks
        for (let i = 0; i < 6; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 40 + Math.random() * 40;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 2 + Math.random() * 3,
            type: 'spark',
            life: 0.5
          });
        }
      }
      
      static createMuzzleFlash(x, y, angle = 0) {
        // Main muzzle flash
        this.createParticle({
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          size: 15 + Math.random() * 10,
          type: 'muzzle',
          life: 0.2,
          rotation: angle
        });
        
        // Sparks from muzzle
        for (let i = 0; i < 3; i++) {
          const sparkAngle = angle + (Math.random() - 0.5) * 0.5;
          const speed = 30 + Math.random() * 20;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(sparkAngle) * speed,
            vy: Math.sin(sparkAngle) * speed,
            size: 1 + Math.random() * 2,
            type: 'spark',
            life: 0.3
          });
        }
      }
      
      static createBulletTrail(x, y, targetX, targetY, bulletType = 'mg') {
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        // Create trail particles along bullet path
        const trailLength = Math.min(distance, 60);
        const numTrails = Math.floor(trailLength / 10);
        
        for (let i = 0; i < numTrails; i++) {
          const progress = i / numTrails;
          const trailX = x + dx * progress;
          const trailY = y + dy * progress;
          
          this.createParticle({
            x: trailX,
            y: trailY,
            vx: 0,
            vy: 0,
            size: bulletType === 'artillery' ? 4 : 2,
            type: 'trail',
            life: 0.3,
            rotation: angle,
            delay: i * 0.02 // Stagger the trail
          });
        }
      }
      
      static createArtilleryShell(x, y, targetX, targetY) {
        // Create shell particle that follows arc
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        this.createParticle({
          x: x,
          y: y,
          vx: dx * 0.01,
          vy: dy * 0.01 - distance * 0.001, // Arc trajectory
          size: 6,
          type: 'shell',
          life: 0.4,
          gravity: 0.5
        });
      }
      
      static createParticle(config) {
        const particle = document.createElement('div');
        particle.className = `particle ${config.type}`;
        particle.style.width = `${config.size}px`;
        particle.style.height = `${config.size}px`;
        particle.style.left = `${config.x - config.size/2}px`;
        particle.style.top = `${config.y - config.size/2}px`;
        
        if (config.rotation !== undefined) {
          particle.style.transform = `rotate(${config.rotation}rad)`;
        }
        
        if (config.delay) {
          particle.style.animationDelay = `${config.delay}s`;
        }
        
        gameBoard.appendChild(particle);
        
        const particleObj = {
          element: particle,
          x: config.x,
          y: config.y,
          vx: config.vx || 0,
          vy: config.vy || 0,
          size: config.size,
          life: config.life,
          maxLife: config.life,
          type: config.type,
          gravity: config.gravity || 0
        };
        
        gameState.particles.push(particleObj);
        
        // Remove particle after animation
        setTimeout(() => {
          this.removeParticle(particleObj);
        }, config.life * 1000);
      }
      
      static updateParticles(deltaTime) {
        const particlesToRemove = [];
        
        gameState.particles.forEach(particle => {
          // Update physics for certain particle types
          if (particle.type === 'explosion' || particle.type === 'spark' || particle.type === 'shell') {
            particle.x += particle.vx * deltaTime * 0.01;
            particle.y += particle.vy * deltaTime * 0.01;
            
            if (particle.gravity) {
              particle.vy += particle.gravity * deltaTime * 0.1;
            }
            
            particle.element.style.left = `${particle.x - particle.size/2}px`;
            particle.element.style.top = `${particle.y - particle.size/2}px`;
          }
          
          // Update life
          particle.life -= deltaTime * 0.001;
          if (particle.life <= 0) {
            particlesToRemove.push(particle);
          }
        });
        
        particlesToRemove.forEach(particle => this.removeParticle(particle));
      }
      
      static removeParticle(particle) {
        if (particle.element && particle.element.parentNode) {
          particle.element.remove();
        }
        const index = gameState.particles.indexOf(particle);
        if (index !== -1) {
          gameState.particles.splice(index, 1);
        }
      }
      
      static clearAllParticles() {
        gameState.particles.forEach(particle => {
          if (particle.element && particle.element.parentNode) {
            particle.element.remove();
          }
        });
        gameState.particles = [];
      }
    }

    // Dynamic Lighting System
    class LightingSystem {
      static createExplosionLight(x, y, intensity = 1) {
        const light = document.createElement('div');
        light.className = 'light-effect explosion-light';
        const size = 80 * intensity;
        light.style.width = `${size}px`;
        light.style.height = `${size}px`;
        light.style.left = `${x - size/2}px`;
        light.style.top = `${y - size/2}px`;
        
        gameBoard.appendChild(light);
        
        // Add screen flash for large explosions
        if (intensity > 1.5) {
          this.createScreenFlash();
        }
        
        setTimeout(() => light.remove(), 800);
      }
      
      static createMuzzleLight(x, y, angle = 0) {
        const light = document.createElement('div');
        light.className = 'light-effect muzzle-light';
        light.style.width = '40px';
        light.style.height = '40px';
        light.style.left = `${x - 20}px`;
        light.style.top = `${y - 20}px`;
        
        gameBoard.appendChild(light);
        setTimeout(() => light.remove(), 150);
      }
      
      static createShellLight(x, y) {
        const light = document.createElement('div');
        light.className = 'light-effect shell-light';
        light.style.width = '30px';
        light.style.height = '30px';
        light.style.left = `${x - 15}px`;
        light.style.top = `${y - 15}px`;
        
        gameBoard.appendChild(light);
        setTimeout(() => light.remove(), 400);
      }
      
      static createScreenFlash() {
        const flash = document.createElement('div');
        flash.className = 'screen-flash';
        gameBoard.appendChild(flash);
        setTimeout(() => flash.remove(), 100);
      }
      
      static addResourceGlow(element, x, y) {
        const glow = document.createElement('div');
        glow.className = 'light-effect resource-glow';
        glow.style.width = '80px';
        glow.style.height = '80px';
        glow.style.left = `${x - 40}px`;
        glow.style.top = `${y - 40}px`;
        
        gameBoard.appendChild(glow);
        
        // Store reference to remove later
        element.lightGlow = glow;
      }
      
      static removeResourceGlow(element) {
        if (element.lightGlow && element.lightGlow.parentNode) {
          element.lightGlow.remove();
          element.lightGlow = null;
        }
      }
      
      static clearAllLights() {
        document.querySelectorAll('.light-effect').forEach(light => light.remove());
        document.querySelectorAll('.screen-flash').forEach(flash => flash.remove());
      }
    }

    // Weather System
    class WeatherSystem {
      static weatherTypes = ['clear', 'rain', 'fog', 'snow'];
      static weatherOverlay = null;
      static weatherIndicator = null;
      
      static init() {
        this.weatherOverlay = document.getElementById('weather-overlay');
        this.weatherIndicator = document.getElementById('weather-indicator');
      }
      
      static updateWeather(currentTime) {
        // Change weather every 30-60 seconds
        if (currentTime - gameState.weather.lastChange > 30000 + Math.random() * 30000) {
          this.changeWeather();
          gameState.weather.lastChange = currentTime;
        }
        
        // Update weather effects
        this.updateWeatherEffects();
      }
      
      static changeWeather() {
        // More likely to have clear weather, less chance of severe weather
        const weatherChances = [0.4, 0.25, 0.2, 0.15]; // clear, rain, fog, snow
        const random = Math.random();
        let cumulativeChance = 0;
        
        for (let i = 0; i < this.weatherTypes.length; i++) {
          cumulativeChance += weatherChances[i];
          if (random <= cumulativeChance) {
            gameState.weather.type = this.weatherTypes[i];
            break;
          }
        }
        
        // Set intensity (0.3 to 1.0)
        gameState.weather.intensity = 0.3 + Math.random() * 0.7;
        
        this.applyWeatherEffects();
        this.updateWeatherIndicator();
      }
      
      static applyWeatherEffects() {
        // Clear previous weather effects
        this.clearWeatherEffects();
        
        const weather = gameState.weather;
        
        switch (weather.type) {
          case 'rain':
            this.createRainEffect(weather.intensity);
            this.applyVisibilityReduction('light');
            break;
          case 'fog':
            this.createFogEffect(weather.intensity);
            this.applyVisibilityReduction('heavy');
            break;
          case 'snow':
            this.createSnowEffect(weather.intensity);
            this.applyVisibilityReduction('light');
            break;
          default:
            this.clearVisibilityEffects();
        }
      }
      
      static createRainEffect(intensity) {
        const numDrops = Math.floor(50 * intensity);
        
        for (let i = 0; i < numDrops; i++) {
          setTimeout(() => {
            if (gameState.weather.type === 'rain') {
              this.createRainDrop();
            }
          }, Math.random() * 1000);
        }
        
        // Continue creating rain drops while weather is active
        if (gameState.weather.type === 'rain') {
          setTimeout(() => {
            if (gameState.weather.type === 'rain') {
              this.createRainEffect(intensity);
            }
          }, 1000);
        }
      }
      
      static createRainDrop() {
        const drop = document.createElement('div');
        drop.className = 'rain-drop';
        drop.style.left = `${Math.random() * 100}%`;
        drop.style.top = '-20px';
        drop.style.animationDuration = `${0.5 + Math.random() * 0.5}s`;
        drop.style.animationDelay = `${Math.random() * 0.2}s`;
        
        this.weatherOverlay.appendChild(drop);
        
        setTimeout(() => {
          if (drop.parentNode) {
            drop.remove();
          }
        }, 1000);
      }
      
      static createFogEffect(intensity) {
        const fog = document.createElement('div');
        fog.className = 'fog-layer';
        fog.style.opacity = intensity * 0.8;
        this.weatherOverlay.appendChild(fog);
      }
      
      static createSnowEffect(intensity) {
        const numFlakes = Math.floor(30 * intensity);
        
        for (let i = 0; i < numFlakes; i++) {
          setTimeout(() => {
            if (gameState.weather.type === 'snow') {
              this.createSnowFlake();
            }
          }, Math.random() * 2000);
        }
        
        // Continue creating snowflakes
        if (gameState.weather.type === 'snow') {
          setTimeout(() => {
            if (gameState.weather.type === 'snow') {
              this.createSnowEffect(intensity);
            }
          }, 2000);
        }
      }
      
      static createSnowFlake() {
        const flake = document.createElement('div');
        flake.className = 'snow-flake';
        flake.style.left = `${Math.random() * 100}%`;
        flake.style.top = '-10px';
        flake.style.animationDuration = `${2 + Math.random() * 3}s`;
        flake.style.animationDelay = `${Math.random() * 1}s`;
        
        this.weatherOverlay.appendChild(flake);
        
        setTimeout(() => {
          if (flake.parentNode) {
            flake.remove();
          }
        }, 6000);
      }
      
      static applyVisibilityReduction(level) {
        const gameBoard = document.getElementById('game-board');
        
        if (level === 'light') {
          gameBoard.classList.add('weather-reduced-visibility');
        } else if (level === 'heavy') {
          gameBoard.classList.add('weather-heavy-reduced-visibility');
        }
        
        // Reduce tower range in bad weather
        gameState.towers.forEach(tower => {
          if (!tower.originalRange) {
            tower.originalRange = tower.range;
          }
          
          const reduction = level === 'heavy' ? 0.7 : 0.85;
          tower.range = tower.originalRange * reduction;
          
          // Update range indicator
          const rangeIndicator = tower.element.querySelector('.tower-range');
          if (rangeIndicator) {
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
        });
      }
      
      static clearVisibilityEffects() {
        const gameBoard = document.getElementById('game-board');
        gameBoard.classList.remove('weather-reduced-visibility', 'weather-heavy-reduced-visibility');
        
        // Restore original tower ranges
        gameState.towers.forEach(tower => {
          if (tower.originalRange) {
            tower.range = tower.originalRange;
            
            // Update range indicator
            const rangeIndicator = tower.element.querySelector('.tower-range');
            if (rangeIndicator) {
              rangeIndicator.style.width = `${tower.range * 2}px`;
              rangeIndicator.style.height = `${tower.range * 2}px`;
              rangeIndicator.style.left = `-${tower.range - 20}px`;
              rangeIndicator.style.top = `-${tower.range - 20}px`;
            }
          }
        });
      }
      
      static clearWeatherEffects() {
        if (this.weatherOverlay) {
          this.weatherOverlay.innerHTML = '';
        }
        this.clearVisibilityEffects();
      }
      
      static updateWeatherIndicator() {
        if (this.weatherIndicator) {
          const weather = gameState.weather;
          let text = weather.type.charAt(0).toUpperCase() + weather.type.slice(1);
          
          if (weather.type !== 'clear') {
            const intensityText = weather.intensity > 0.7 ? 'Heavy ' : weather.intensity > 0.4 ? 'Light ' : '';
            text = intensityText + text;
          }
          
          this.weatherIndicator.textContent = text;
          this.weatherIndicator.style.display = weather.type === 'clear' ? 'none' : 'block';
        }
      }
      
      static updateWeatherEffects() {
        // Update any dynamic weather effects here if needed
      }
    }

    // Map generation system
    class MapGenerator {
      constructor(width = 800, height = 500) {
        this.width = width;
        this.height = height;
        this.gridSize = 25;
        this.seed = Math.random();
      }

      // Simple seeded random number generator
      seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      }

      // Generate procedural path through the map
      generatePath(seed = this.seed) {
        const pathSegments = [];
        const startX = 50 + this.seededRandom(seed) * 100;
        const endX = this.width - 50;
        const startY = this.seededRandom(seed + 1) * this.height;
        
        // Create strategic waypoints with some randomization
        const waypoints = [
          { x: startX, y: startY },
          { x: startX + 150 + this.seededRandom(seed + 2) * 100, y: startY + (this.seededRandom(seed + 3) - 0.5) * 200 },
          { x: this.width * 0.5 + (this.seededRandom(seed + 4) - 0.5) * 150, y: this.height * 0.3 + this.seededRandom(seed + 5) * 200 },
          { x: this.width * 0.7 + (this.seededRandom(seed + 6) - 0.5) * 100, y: this.height * 0.6 + (this.seededRandom(seed + 7) - 0.5) * 150 },
          { x: endX, y: this.height * 0.4 + this.seededRandom(seed + 8) * 200 }
        ];

        // Create curved segments between waypoints
        for (let i = 0; i < waypoints.length - 1; i++) {
          const start = waypoints[i];
          const end = waypoints[i + 1];
          
          // Generate control points for smooth curves
          const controlOffset = 80 + this.seededRandom(seed + i + 10) * 40;
          const control1 = {
            x: start.x + controlOffset * (this.seededRandom(seed + i + 20) - 0.5),
            y: start.y + controlOffset * (this.seededRandom(seed + i + 21) - 0.5)
          };
          const control2 = {
            x: end.x - controlOffset * (this.seededRandom(seed + i + 22) - 0.5),
            y: end.y - controlOffset * (this.seededRandom(seed + i + 23) - 0.5)
          };

          pathSegments.push({
            type: 'curved',
            points: [start, control1, control2, end]
          });
        }

        return pathSegments;
      }

      // Generate strategic terrain features
      generateTerrain(seed = this.seed, pathSegments) {
        const terrain = [];
        const forbiddenAreas = this.calculateForbiddenAreas(pathSegments);

        // Generate resource nodes (provide bonus income)
        const resourceCount = 2 + Math.floor(this.seededRandom(seed + 40) * 2);
        for (let i = 0; i < resourceCount; i++) {
          const resource = this.generateTerrainFeature('resource', seed + 50 + i, forbiddenAreas);
          if (resource) terrain.push(resource);
        }

        // Generate hills (provide tower range bonus)
        const hillCount = 3 + Math.floor(this.seededRandom(seed + 60) * 3);
        for (let i = 0; i < hillCount; i++) {
          const hill = this.generateTerrainFeature('hill', seed + 100 + i, forbiddenAreas);
          if (hill) terrain.push(hill);
        }

        // Generate forests (provide tower concealment)
        const forestCount = 4 + Math.floor(this.seededRandom(seed + 70) * 4);
        for (let i = 0; i < forestCount; i++) {
          const forest = this.generateTerrainFeature('forest', seed + 200 + i, forbiddenAreas);
          if (forest) terrain.push(forest);
        }

        // Generate rocks and decorative elements
        const decorCount = 8 + Math.floor(this.seededRandom(seed + 80) * 8);
        for (let i = 0; i < decorCount; i++) {
          const decor = this.generateTerrainFeature('decoration', seed + 300 + i, forbiddenAreas);
          if (decor) terrain.push(decor);
        }

        return terrain;
      }

      generateTerrainFeature(type, seed, forbiddenAreas) {
        const maxAttempts = 20;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const x = 50 + this.seededRandom(seed + attempt) * (this.width - 100);
          const y = 50 + this.seededRandom(seed + attempt + 1000) * (this.height - 100);
          
          if (!this.isPositionForbidden(x, y, forbiddenAreas)) {
            const feature = { x, y, type };
            
            // Add type-specific properties
            if (type === 'resource') {
              feature.radius = 50;
              feature.bonus = 'income';
              feature.icon = 'üí∞';
              feature.income = 2; // Resources per second
              feature.lastIncome = 0;
            } else if (type === 'hill') {
              feature.radius = 60 + this.seededRandom(seed + attempt + 2000) * 40;
              feature.bonus = 'range';
              feature.icon = 'üèîÔ∏è';
            } else if (type === 'forest') {
              feature.radius = 40 + this.seededRandom(seed + attempt + 3000) * 30;
              feature.bonus = 'concealment';
              feature.icon = 'üå≤';
            } else {
              feature.radius = 25;
              feature.icon = ['ü™®', 'üèöÔ∏è', '‚õ™'][Math.floor(this.seededRandom(seed + attempt + 4000) * 3)];
            }
            
            // Add to forbidden areas for future features
            forbiddenAreas.push({
              x: x - feature.radius,
              y: y - feature.radius,
              width: feature.radius * 2,
              height: feature.radius * 2
            });
            
            return feature;
          }
        }
        return null;
      }

      calculateForbiddenAreas(pathSegments) {
        const areas = [];
        pathSegments.forEach(segment => {
          if (segment.type === 'curved') {
            segment.points.forEach(point => {
              areas.push({
                x: point.x - 60,
                y: point.y - 60,
                width: 120,
                height: 120
              });
            });
          }
        });
        return areas;
      }

      isPositionForbidden(x, y, forbiddenAreas) {
        return forbiddenAreas.some(area => 
          x >= area.x && x <= area.x + area.width && 
          y >= area.y && y <= area.y + area.height
        );
      }
    }

    // Global map generator instance
    const mapGenerator = new MapGenerator();
    let pathSegments = [];
    let terrainFeatures = [];

    // Generate path points for enemy movement
    let path = [];
    const pathResolution = 10; // Points per segment

    function generateMapData(seed) {
      mapGenerator.seed = seed || Math.random();
      pathSegments = mapGenerator.generatePath();
      terrainFeatures = mapGenerator.generateTerrain(mapGenerator.seed, pathSegments);
      
      // Generate path points for enemy movement
      path = [];
      pathSegments.forEach(segment => {
        if (segment.type === 'curved') {
          // Generate points along Bezier curve
          for (let t = 0; t <= 1; t += 1/pathResolution) {
            const points = segment.points;
            // Cubic Bezier formula
            const x = Math.pow(1-t, 3) * points[0].x + 
                    3 * Math.pow(1-t, 2) * t * points[1].x + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].x + 
                    Math.pow(t, 3) * points[3].x;
            const y = Math.pow(1-t, 3) * points[0].y + 
                    3 * Math.pow(1-t, 2) * t * points[1].y + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].y + 
                    Math.pow(t, 3) * points[3].y;
            path.push({ x, y });
          }
        }
      });
    }

    // Tower definitions
    const towerTypes = {
      mg: { name: "Machine Gun", cost: 25, damage: 1, range: 120, fireRate: 500, targets: ["infantry", "tank", "heavytank"], icon: "üë®‚Äçü¶Ø", ammo: 20, maxAmmo: 20, reloadTime: 2000 },
      artillery: { name: "Artillery", cost: 50, damage: 3, range: 180, fireRate: 2000, targets: ["infantry", "tank", "heavytank"], icon: "üí£", splash: 60, ammo: 3, maxAmmo: 3, reloadTime: 5000 },
      aa: { name: "Anti-Air", cost: 40, damage: 2, range: 150, fireRate: 800, targets: ["aircraft"], icon: "‚ö°", ammo: 15, maxAmmo: 15, reloadTime: 3000 },
      sniper: { name: "Sniper", cost: 60, damage: 6, range: 250, fireRate: 3000, targets: ["infantry", "tank", "heavytank"], icon: "üî≠", ammo: 5, maxAmmo: 5, reloadTime: 4000 },
      engineer: { name: "Engineer", cost: 45, damage: 0, range: 100, fireRate: 5000, targets: [], icon: "üîß", ammo: 3, maxAmmo: 3, reloadTime: 8000, special: "construction" },
      radar: { name: "Radar", cost: 35, damage: 0, range: 200, fireRate: 0, targets: [], icon: "üì°", ammo: 0, maxAmmo: 0, reloadTime: 0, special: "detection" },
      command: { name: "Command Post", cost: 80, damage: 0, range: 150, fireRate: 0, targets: [], icon: "üèõÔ∏è", ammo: 0, maxAmmo: 0, reloadTime: 0, special: "support" }
    };

    // Enemy definitions
    const enemyTypes = {
      infantry: { name: "Infantry", health: 3, speed: 1, worth: 5, damage: 1, icon: "üë§", scoreValue: 10 },
      tank: { name: "Tank", health: 8, speed: 0.5, worth: 10, damage: 2, icon: "üöú", scoreValue: 25 },
      heavytank: { name: "Heavy Tank", health: 20, speed: 0.3, worth: 20, damage: 4, icon: "üöõ", scoreValue: 50 },
      aircraft: { name: "Aircraft", health: 4, speed: 1.5, worth: 8, damage: 1, icon: "‚úàÔ∏è", scoreValue: 20 }
    };

    // Elite enemy modifiers
    const eliteModifiers = { health: 2, speed: 1.2, worth: 2, scoreValue: 2 };

    // Wave definitions
    const waveDefinitions = [
      { infantry: 10 },
      { infantry: 15, tank: 2 },
      { infantry: 10, aircraft: 5 },
      { infantry: 15, tank: 5 },
      { infantry: 10, tank: 5, aircraft: 5 },
      { infantry: 20, tank: 8 },
      { heavytank: 2, infantry: 10, aircraft: 8 },
      { infantry: 15, tank: 5, aircraft: 10 },
      { infantry: 15, tank: 10, aircraft: 5, heavytank: 2 },
      { infantry: 20, tank: 10, aircraft: 10 },
      { infantry: 25, tank: 15, aircraft: 10, elites: ["tank"] },
      { infantry: 30, tank: 20, aircraft: 15, heavytank: 10, elites: ["heavytank", "aircraft"] }
    ];

    // Difficulty settings
    const difficultySettings = {
      normal: { enemyHealthMultiplier: 1, enemySpeedMultiplier: 1, resourceMultiplier: 1, waveSpawnDelay: 800 },
      hard: { enemyHealthMultiplier: 1.5, enemySpeedMultiplier: 1.01, resourceMultiplier: 0.8, waveSpawnDelay: 600 },
      veteran: { enemyHealthMultiplier: 2, enemySpeedMultiplier: 1.05, resourceMultiplier: 0.6, waveSpawnDelay: 400 }
    };

    // DOM Elements
    const gameBoard = document.getElementById('game-board');
    const waveInfoElement = document.getElementById('wave-info');
    const resourcesElement = document.getElementById('resources');
    const livesElement = document.getElementById('lives');
    const scoreElement = document.getElementById('score-display');
    const startButton = document.getElementById('start-button');
    const gameOverPanel = document.getElementById('game-over');
    const levelCompletePanel = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const victoryScoreElement = document.getElementById('victory-score');
    const upgradePanel = document.getElementById('upgrade-panel');

    // Create path visualization
    function createPathVisualization() {
      // Create path segments
      pathSegments.forEach((segment, i) => {
        if (segment.type === 'curved') {
          const points = segment.points;
          // Create path element for this segment
          const pathElement = document.createElement('div');
          pathElement.className = 'path';
          
          // Set path dimensions and position based on the points
          const startX = Math.min(...points.map(p => p.x));
          const startY = Math.min(...points.map(p => p.y));
          const endX = Math.max(...points.map(p => p.x));
          const endY = Math.max(...points.map(p => p.y));
          
          pathElement.style.left = `${startX - 30}px`;
          pathElement.style.top = `${startY}px`;
          pathElement.style.width = `${endX - startX + 60}px`;
          pathElement.style.height = `${endY - startY + 60}px`;
          
          gameBoard.appendChild(pathElement);
        }
      });
    }

    // Add procedurally generated terrain elements
    function addTerrainElements() {
      // Clear existing terrain
      gameState.terrainElements.forEach(element => element.remove());
      gameState.terrainElements = [];
      
      // Add generated strategic terrain
      terrainFeatures.forEach(feature => {
        const terrainElement = document.createElement('div');
        terrainElement.className = `terrain ${feature.type}`;
        terrainElement.textContent = feature.icon;
        terrainElement.style.left = `${feature.x - feature.radius/2}px`;
        terrainElement.style.top = `${feature.y - feature.radius/2}px`;
        terrainElement.style.width = `${feature.radius}px`;
        terrainElement.style.height = `${feature.radius}px`;
        terrainElement.style.fontSize = feature.type === 'decoration' ? '20px' : '24px';
        terrainElement.style.display = 'flex';
        terrainElement.style.alignItems = 'center';
        terrainElement.style.justifyContent = 'center';
        
        // Add bonus indicator for strategic terrain
        if (feature.bonus) {
          const bonusIndicator = document.createElement('div');
          bonusIndicator.className = 'terrain-bonus';
          if (feature.bonus === 'range') {
            bonusIndicator.textContent = '+RNG';
          } else if (feature.bonus === 'concealment') {
            bonusIndicator.textContent = '+CON';
          } else if (feature.bonus === 'income') {
            bonusIndicator.textContent = '+$$$';
          }
          terrainElement.appendChild(bonusIndicator);
          
          // Store terrain data for tower bonuses
          terrainElement.terrainData = feature;
          
          // Add lighting effects for resource nodes
          if (feature.bonus === 'income') {
            LightingSystem.addResourceGlow(terrainElement, feature.x, feature.y);
          }
        }
        
        gameBoard.appendChild(terrainElement);
        gameState.terrainElements.push(terrainElement);
      });
    }

    // Initialize the game
    function initGame() {
      generateMapData(); // Generate new map
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
      
      // Initialize weather system
      WeatherSystem.init();
      
      // Set up difficulty selection
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
          this.classList.add('selected');
          gameState.difficulty = this.getAttribute('data-difficulty');
        });
      });
      
      // Event listener for tower placement
      gameBoard.addEventListener('click', function(event) {
        if (gameState.selectedTowerType) {
          const rect = gameBoard.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          placeTower(x, y);
        }
      });
    }

    // Optimized game loop
    function gameLoop(timestamp) {
      if (!gameState.lastFrameTime) {
        gameState.lastFrameTime = timestamp;
      }
      
      const deltaTime = timestamp - gameState.lastFrameTime;
      gameState.lastFrameTime = timestamp;
      
      if (!gameState.gameOver && !gameState.victory) {
        // Use frame counter to stagger calculations
        gameState.frameCounter++;
        
        // Always update enemy positions every frame
        moveEnemies(deltaTime);
        updateBullets(deltaTime);
        ParticleSystem.updateParticles(deltaTime);
        
        // Stagger more expensive operations
        if (gameState.frameCounter % 2 === 0) {
          checkTowerFiring(deltaTime);
        }
        
        if (gameState.frameCounter % 5 === 0) {
          checkWaveStatus();
          checkTowerReloading();
          updateResourceNodes();
          checkMineExplosions();
          updateCommandBonuses();
          updateSupplyConvoys(deltaTime);
          spawnSupplyConvoy();
          updateTowerAnimations();
        }
        
        if (gameState.frameCounter % 60 === 0) { // Update weather less frequently
          WeatherSystem.updateWeather(timestamp);
        }
        
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    // Optimized enemy movement along curved path
    function moveEnemies(deltaTime) {
      const enemiesToRemove = [];
      
      gameState.enemies.forEach(enemy => {
        if (enemy.pathIndex >= path.length - 1) {
          // Enemy reached the end
          gameState.lives -= enemy.damage;
          updateInfoPanel();
          enemiesToRemove.push(enemy);
          
          // Check if game over
          if (gameState.lives <= 0) {
            endGame(false);
          }
          return;
        }
        
        // Calculate movement along path
        const speedFactor = enemy.speed * (deltaTime / 16) * gameState.enemySpeedMultiplier;
        enemy.pathProgress += speedFactor;
        
        while (enemy.pathProgress >= 1 && enemy.pathIndex < path.length - 1) {
          enemy.pathProgress -= 1;
          enemy.pathIndex++;
        }
        
        // Interpolate position between current and next path point
        const currentPoint = path[enemy.pathIndex];
        const nextIndex = Math.min(enemy.pathIndex + 1, path.length - 1);
        const nextPoint = path[nextIndex];
        
        enemy.x = currentPoint.x + (nextPoint.x - currentPoint.x) * enemy.pathProgress;
        enemy.y = currentPoint.y + (nextPoint.y - currentPoint.y) * enemy.pathProgress;
        
        // Update visual position
        enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
        enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
      });
      
      // Remove enemies
      enemiesToRemove.forEach(enemy => removeEnemy(enemy));
    }

    // Tower firing with efficiency improvements
    function checkTowerFiring(deltaTime) {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        // Skip special towers that don't fire
        if (tower.special === 'detection' || tower.special === 'support') return;
        
        // Skip if reloading or no ammo
        if (tower.reloading || tower.ammo <= 0) return;
        if (currentTime - tower.lastFired < tower.fireRate) return;
        
        const target = findTarget(tower);
        if (target) {
          fireTower(tower, target);
          tower.lastFired = currentTime;
          tower.ammo--;
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = `${(tower.ammo / tower.maxAmmo) * 100}%`;
          }
          
          // Start reloading if out of ammo
          if (tower.ammo <= 0) {
            startReloading(tower);
          }
        }
      });
    }

    // Batch check tower reloading status
    function checkTowerReloading() {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        if (tower.reloading && currentTime - tower.reloadStart >= tower.reloadTime) {
          tower.reloading = false;
          tower.ammo = tower.maxAmmo;
          tower.element.style.opacity = '1';
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = '100%';
          }
        }
      });
    }

    // Update resource nodes to generate income
    function updateResourceNodes() {
      const currentTime = Date.now();
      
      terrainFeatures.forEach(feature => {
        if (feature.bonus === 'income') {
          if (currentTime - feature.lastIncome >= 1000) { // Every 1 second
            // Check if any tower is near this resource node
            const nearbyTower = gameState.towers.find(tower => {
              const dx = tower.x - feature.x;
              const dy = tower.y - feature.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              return distance <= feature.radius;
            });
            
            if (nearbyTower) {
              gameState.resources += feature.income;
              updateInfoPanel();
              feature.lastIncome = currentTime;
              
              // Visual feedback
              showResourceGain(feature.x, feature.y, feature.income);
            }
          }
        }
      });
    }

    // Show visual feedback for resource gain
    function showResourceGain(x, y, amount) {
      const popup = document.createElement('div');
      popup.textContent = `+${amount}`;
      popup.style.position = 'absolute';
      popup.style.left = `${x}px`;
      popup.style.top = `${y - 20}px`;
      popup.style.color = '#32cd32';
      popup.style.fontWeight = 'bold';
      popup.style.fontSize = '14px';
      popup.style.pointerEvents = 'none';
      popup.style.zIndex = '15';
      popup.style.animation = 'fadeUpOut 1s forwards';
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeUpOut {
          0% { opacity: 1; transform: translateY(0); }
          100% { opacity: 0; transform: translateY(-30px); }
        }
      `;
      document.head.appendChild(style);
      
      gameBoard.appendChild(popup);
      setTimeout(() => popup.remove(), 1000);
    }

    // Check for mine explosions
    function checkMineExplosions() {
      gameState.mines.forEach((mine, index) => {
        if (mine.triggered) return;
        
        // Check if any enemy is near the mine
        for (let enemy of gameState.enemies) {
          const dx = enemy.x - mine.x;
          const dy = enemy.y - mine.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 20) {
            // Trigger mine explosion
            mine.triggered = true;
            createExplosion(mine.x, mine.y, mine.damage);
            mine.element.remove();
            gameState.mines.splice(index, 1);
            break;
          }
        }
      });
    }

    // Optimized bullet movement and collision detection
    function updateBullets(deltaTime) {
      const bulletsToRemove = [];
      
      gameState.bullets.forEach(bullet => {
        // Move bullet
        const moveSpeed = 0.4 * deltaTime;
        const dx = bullet.targetX - bullet.x;
        const dy = bullet.targetY - bullet.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          bullet.x += (dx / distance) * moveSpeed;
          bullet.y += (dy / distance) * moveSpeed;
          bullet.distance += moveSpeed;
        }
        
        bullet.element.style.left = `${bullet.x - 3}px`;
        bullet.element.style.top = `${bullet.y - 3}px`;
        
        // Artillery explosion
        if (bullet.type === 'artillery' && bullet.distance >= bullet.maxDistance * 0.9) {
          createExplosion(bullet.targetX, bullet.targetY, bullet.damage);
          bulletsToRemove.push(bullet);
          return;
        }
        
        // Check for hits using spatial partitioning
        let hitEnemy = null;
        for (let i = 0; i < gameState.enemies.length && !hitEnemy; i++) {
          const enemy = gameState.enemies[i];
          const hitDx = enemy.x - bullet.x;
          const hitDy = enemy.y - bullet.y;
          const hitDistance = Math.sqrt(hitDx * hitDx + hitDy * hitDy);
          
          if (hitDistance < 15) {
            hitEnemy = enemy;
            damageEnemy(enemy, bullet.damage);
          }
        }
        
        // Remove bullet if hit or out of range
        if (hitEnemy || bullet.distance > bullet.maxDistance) {
          bulletsToRemove.push(bullet);
        }
      });
      
      // Batch remove bullets
      bulletsToRemove.forEach(bullet => {
        bullet.element.remove();
        const index = gameState.bullets.indexOf(bullet);
        if (index !== -1) {
          gameState.bullets.splice(index, 1);
        }
      });
    }

    // Special tower implementations
    function addEngineerActions(tower) {
      const actionPanel = document.createElement('div');
      actionPanel.className = 'action-buttons';
      actionPanel.innerHTML = `
        <div class="action-btn" onclick="buildWall(${tower.x}, ${tower.y})">Build Wall ($15)</div>
        <div class="action-btn" onclick="placeMine(${tower.x}, ${tower.y})">Place Mine ($10)</div>
      `;
      tower.element.appendChild(actionPanel);
      
      tower.element.addEventListener('click', (e) => {
        e.stopPropagation();
        document.querySelectorAll('.action-buttons').forEach(panel => panel.style.display = 'none');
        actionPanel.style.display = actionPanel.style.display === 'block' ? 'none' : 'block';
      });
    }

    function activateRadarTower(tower) {
      // Create radar sweep effect
      const radarSweep = document.createElement('div');
      radarSweep.className = 'radar-sweep';
      radarSweep.style.width = `${tower.range * 2}px`;
      radarSweep.style.height = `${tower.range * 2}px`;
      radarSweep.style.left = `-${tower.range - 20}px`;
      radarSweep.style.top = `-${tower.range - 20}px`;
      tower.element.appendChild(radarSweep);
      
      // Enable radar coverage globally
      gameState.radarCoverage = true;
      updateRadarEffects();
    }

    function activateCommandPost(tower) {
      // Create command aura
      const commandAura = document.createElement('div');
      commandAura.className = 'command-aura';
      commandAura.style.width = `${tower.range * 2}px`;
      commandAura.style.height = `${tower.range * 2}px`;
      commandAura.style.left = `-${tower.range - 20}px`;
      commandAura.style.top = `-${tower.range - 20}px`;
      tower.element.appendChild(commandAura);
      
      // Apply bonuses to nearby towers
      updateCommandBonuses();
    }

    function buildWall(engineerX, engineerY) {
      if (gameState.resources < 15) return;
      
      // Find nearby position for wall
      const wallX = engineerX + (Math.random() - 0.5) * 80;
      const wallY = engineerY + (Math.random() - 0.5) * 80;
      
      if (isOnPath(wallX, wallY) || isTowerConflict(wallX, wallY)) return;
      
      gameState.resources -= 15;
      updateInfoPanel();
      
      const wall = document.createElement('div');
      wall.className = 'wall';
      wall.style.left = `${wallX - 10}px`;
      wall.style.top = `${wallY - 10}px`;
      gameBoard.appendChild(wall);
      
      gameState.walls.push({
        x: wallX, y: wallY, element: wall, health: 5, maxHealth: 5
      });
      
      // Walls block enemy movement temporarily
      setTimeout(() => {
        wall.remove();
        const index = gameState.walls.findIndex(w => w.element === wall);
        if (index !== -1) gameState.walls.splice(index, 1);
      }, 30000); // 30 seconds
    }

    function placeMine(engineerX, engineerY) {
      if (gameState.resources < 10) return;
      
      const mineX = engineerX + (Math.random() - 0.5) * 100;
      const mineY = engineerY + (Math.random() - 0.5) * 100;
      
      if (isOnPath(mineX, mineY)) {
        gameState.resources -= 10;
        updateInfoPanel();
        
        const mine = document.createElement('div');
        mine.className = 'mine';
        mine.style.left = `${mineX - 7}px`;
        mine.style.top = `${mineY - 7}px`;
        mine.textContent = 'üí•';
        gameBoard.appendChild(mine);
        
        gameState.mines.push({
          x: mineX, y: mineY, element: mine, damage: 8, triggered: false
        });
      }
    }

    function updateRadarEffects() {
      if (gameState.radarCoverage) {
        // Extend AA tower range by 50%
        gameState.towers.forEach(tower => {
          if (tower.type === 'aa' && !tower.radarBoosted) {
            tower.range *= 1.5;
            tower.radarBoosted = true;
            // Update range indicator
            const rangeIndicator = tower.element.querySelector('.tower-range');
            if (rangeIndicator) {
              rangeIndicator.style.width = `${tower.range * 2}px`;
              rangeIndicator.style.height = `${tower.range * 2}px`;
              rangeIndicator.style.left = `-${tower.range - 20}px`;
              rangeIndicator.style.top = `-${tower.range - 20}px`;
            }
          }
        });
      }
    }

    function updateCommandBonuses() {
      const commandPosts = gameState.towers.filter(t => t.type === 'command');
      
      gameState.towers.forEach(tower => {
        if (tower.type !== 'command') {
          let hasCommandBonus = false;
          
          commandPosts.forEach(commandPost => {
            const dx = tower.x - commandPost.x;
            const dy = tower.y - commandPost.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= commandPost.range) {
              hasCommandBonus = true;
            }
          });
          
          // Apply/remove command bonus
          if (hasCommandBonus && !tower.commandBoosted) {
            tower.damage *= 1.3; // 30% damage boost
            tower.fireRate *= 0.8; // 20% faster firing
            tower.commandBoosted = true;
            tower.element.style.boxShadow = '0 0 8px 2px rgba(154, 205, 50, 0.8)';
          } else if (!hasCommandBonus && tower.commandBoosted) {
            tower.damage /= 1.3;
            tower.fireRate /= 0.8;
            tower.commandBoosted = false;
            tower.element.style.boxShadow = '';
          }
        }
      });
    }

    // Helper functions (tower selection, enemy creation, etc.)
    function selectTower(type) {
      closeUpgradePanel();
      document.querySelectorAll('.action-buttons').forEach(panel => panel.style.display = 'none');
      document.querySelectorAll('.tower-option').forEach(o => o.classList.remove('selected'));
      document.querySelector(`.tower-option[data-type="${type}"]`).classList.add('selected');
      gameState.selectedTowerType = type;
    }

    function placeTower(x, y) {
      if (isOnPath(x, y) || isTowerConflict(x, y)) return;
      
      const towerType = towerTypes[gameState.selectedTowerType];
      if (gameState.resources < towerType.cost) return;
      
      gameState.resources -= towerType.cost;
      updateInfoPanel();
      createTower(x, y, gameState.selectedTowerType);
    }

    function isOnPath(x, y) {
      // Check distance to path points (dynamic path)
      for (let i = 0; i < path.length; i++) {
        const dx = path[i].x - x;
        const dy = path[i].y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 35) return true; // Slightly larger radius for curved paths
      }
      return false;
    }

    function isTowerConflict(x, y) {
      return gameState.towers.some(tower => {
        const dx = tower.x - x;
        const dy = tower.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 40;
      });
    }

    // Check for terrain bonuses at position
    function getTerrainBonus(x, y) {
      for (let terrainElement of gameState.terrainElements) {
        if (terrainElement.terrainData && terrainElement.terrainData.bonus) {
          const terrain = terrainElement.terrainData;
          const dx = terrain.x - x;
          const dy = terrain.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= terrain.radius) {
            return terrain.bonus;
          }
        }
      }
      return null;
    }

    // More efficient tower creation with terrain bonuses
    function createTower(x, y, type) {
      const tower = document.createElement('div');
      tower.className = `tower ${type}`;
      
      // Create turret for rotation
      const turret = document.createElement('div');
      turret.className = 'tower-turret';
      turret.textContent = towerTypes[type].icon;
      tower.appendChild(turret);
      
      // Create barrel for combat towers (not support towers)
      if (towerTypes[type].damage > 0) {
        const barrel = document.createElement('div');
        barrel.className = 'tower-barrel';
        turret.appendChild(barrel);
      }
      
      // Check for terrain bonuses
      const terrainBonus = getTerrainBonus(x, y);
      let baseRange = towerTypes[type].range;
      
      // Apply terrain bonuses
      if (terrainBonus === 'range') {
        baseRange *= 1.25; // 25% range bonus on hills
        tower.style.boxShadow = '0 0 8px 2px rgba(139, 125, 57, 0.6)'; // Golden glow
      } else if (terrainBonus === 'concealment') {
        tower.style.opacity = '0.8'; // Slightly transparent in forests
        tower.style.boxShadow = '0 0 8px 2px rgba(58, 73, 41, 0.6)'; // Green glow
      }
      
      // Create range indicator
      const range = document.createElement('div');
      range.className = 'tower-range';
      range.style.width = `${baseRange * 2}px`;
      range.style.height = `${baseRange * 2}px`;
      range.style.left = `-${baseRange - 20}px`;
      range.style.top = `-${baseRange - 20}px`;
      tower.appendChild(range);
      
      // Create ammo bar
      const ammoBar = document.createElement('div');
      ammoBar.className = 'ammo-bar';
      const ammoFill = document.createElement('div');
      ammoFill.className = 'ammo-fill';
      ammoBar.appendChild(ammoFill);
      tower.appendChild(ammoBar);
      
      // Position tower
      tower.style.left = `${x - 20}px`;
      tower.style.top = `${y - 20}px`;
      gameBoard.appendChild(tower);
      
      // Create tower object with all properties
      const towerObj = {
        x, y, type, element: tower, lastFired: 0,
        damage: towerTypes[type].damage,
        range: baseRange, // Use modified range
        fireRate: towerTypes[type].fireRate,
        targets: towerTypes[type].targets,
        ammo: towerTypes[type].ammo,
        maxAmmo: towerTypes[type].maxAmmo,
        reloadTime: towerTypes[type].reloadTime,
        reloading: false,
        ammoBar: ammoFill,
        level: { damage: 1, range: 1, rate: 1 },
        terrainBonus: terrainBonus, // Store bonus type
        special: towerTypes[type].special || null,
        turret: turret, // Reference to turret element for rotation
        currentRotation: 0 // Track current turret rotation
      };
      
      if (type === 'artillery') {
        towerObj.splash = towerTypes[type].splash;
      }
      
      // Add concealment bonus (AA towers can't target this tower if in forest)
      if (terrainBonus === 'concealment') {
        towerObj.concealed = true;
      }
      
      // Initialize special tower features
      if (type === 'engineer') {
        addEngineerActions(towerObj);
      } else if (type === 'radar') {
        activateRadarTower(towerObj);
      } else if (type === 'command') {
        activateCommandPost(towerObj);
      }
      
      // Add events
      tower.addEventListener('mouseover', () => range.style.display = 'block');
      tower.addEventListener('mouseout', () => range.style.display = 'none');
      tower.addEventListener('click', (e) => {
        e.stopPropagation();
        selectTowerForUpgrade(towerObj);
      });
      
      gameState.towers.push(towerObj);
    }

    // More efficient target finding using spatial partitioning
    function findTarget(tower) {
      let closestEnemy = null;
      let closestDistance = Infinity;
      
      // First pass: filter by type
      const potentialTargets = gameState.enemies.filter(enemy => tower.targets.includes(enemy.type));
      
      // Second pass: find closest in range
      potentialTargets.forEach(enemy => {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= tower.range && distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      return closestEnemy;
    }

    // Tower upgrade panel
    function selectTowerForUpgrade(tower) {
      gameState.selectedTower = tower;
      
      document.getElementById('upgrade-damage').textContent = `Damage +25% ($${30 * tower.level.damage})`;
      document.getElementById('upgrade-range').textContent = `Range +15% ($${25 * tower.level.range})`;
      document.getElementById('upgrade-rate').textContent = `Fire Rate +20% ($${35 * tower.level.rate})`;
      
      document.getElementById('upgrade-damage').classList.toggle('disabled', gameState.resources < 30 * tower.level.damage);
      document.getElementById('upgrade-range').classList.toggle('disabled', gameState.resources < 25 * tower.level.range);
      document.getElementById('upgrade-rate').classList.toggle('disabled', gameState.resources < 35 * tower.level.rate);
      
      const upgradePanel = document.getElementById('upgrade-panel');
      upgradePanel.style.left = `${tower.x + 30}px`;
      upgradePanel.style.top = `${tower.y - 50}px`;
      upgradePanel.style.display = 'block';
    }

    function closeUpgradePanel() {
      document.getElementById('upgrade-panel').style.display = 'none';
      gameState.selectedTower = null;
    }

    function upgradeTower(upgradeType) {
      if (!gameState.selectedTower) return;
      
      const tower = gameState.selectedTower;
      let cost = 0;
      
      switch (upgradeType) {
        case 'damage':
          cost = 30 * tower.level.damage;
          if (gameState.resources >= cost) {
            tower.damage *= 1.25;
            tower.level.damage++;
          }
          break;
        case 'range':
          cost = 25 * tower.level.range;
          if (gameState.resources >= cost) {
            tower.range *= 1.15;
            tower.level.range++;
            
            const rangeIndicator = tower.element.querySelector('.tower-range');
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
          break;
        case 'rate':
          cost = 35 * tower.level.rate;
          if (gameState.resources >= cost) {
            tower.fireRate *= 0.8;
            tower.level.rate++;
          }
          break;
      }
      
      if (cost && gameState.resources >= cost) {
        gameState.resources -= cost;
        updateInfoPanel();
        
        tower.element.style.transform = 'scale(1.3)';
        setTimeout(() => tower.element.style.transform = 'scale(1)', 300);
        
        closeUpgradePanel();
        selectTowerForUpgrade(tower);
      }
    }

    // Wave management with improved efficiency
    function startWave() {
      if (gameState.waveInProgress) return;
      
      gameState.waveInProgress = true;
      startButton.disabled = true;
      startButton.textContent = 'Wave in Progress';
      
      const waveDefinition = waveDefinitions[gameState.currentWave];
      spawnEnemies(waveDefinition);
      
      if (gameState.animationFrameId === null) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function spawnEnemies(waveDefinition) {
      const scaledDefinition = scaleWaveForPerformance(waveDefinition);
      const enemiesToSpawn = [];
      const spawnDelay = difficultySettings[gameState.difficulty].waveSpawnDelay;
      
      // Add normal enemies
      Object.entries(scaledDefinition).forEach(([type, count]) => {
        if (type !== 'elites') {
          for (let i = 0; i < count; i++) {
            enemiesToSpawn.push(type);
          }
        }
      });
      
      // Add elite enemies
      if (scaledDefinition.elites) {
        scaledDefinition.elites.forEach(eliteType => {
          const eliteCount = Math.floor(Math.random() * 2) + 2;
          for (let i = 0; i < eliteCount; i++) {
            enemiesToSpawn.push(`elite_${eliteType}`);
          }
        });
      }
      
      // Shuffle and spawn
      shuffleArray(enemiesToSpawn);
      
      enemiesToSpawn.forEach((enemyType, index) => {
        setTimeout(() => {
          if (!gameState.gameOver && !gameState.victory) {
            if (enemyType.includes('elite_')) {
              createEnemy(enemyType.split('_')[1], true);
            } else {
              createEnemy(enemyType, false);
            }
          }
        }, index * spawnDelay);
      });
    }

    // Dynamic wave scaling based on player performance
    function scaleWaveForPerformance(baseWave) {
      const metrics = gameState.performanceMetrics;
      const scaledWave = { ...baseWave };
      
      // Calculate performance score (0.0 to 2.0)
      const killRatio = Math.min(metrics.enemiesKilled / Math.max(gameState.currentWave * 10, 1), 1.5);
      const waveSuccessRate = metrics.wavesCompleted / Math.max(gameState.currentWave, 1);
      const performanceScore = (killRatio + waveSuccessRate + metrics.efficiency / 100) / 3;
      
      // If player is doing well, increase difficulty
      if (performanceScore > 1.2) {
        Object.keys(scaledWave).forEach(enemyType => {
          if (enemyType !== 'elites') {
            scaledWave[enemyType] = Math.floor(scaledWave[enemyType] * 1.3);
          }
        });
        // Add more elite types for high performers
        if (!scaledWave.elites) scaledWave.elites = [];
        const availableElites = ['tank', 'aircraft', 'heavytank'];
        if (scaledWave.elites.length < 2 && gameState.currentWave > 5) {
          scaledWave.elites.push(availableElites[Math.floor(Math.random() * availableElites.length)]);
        }
      }
      // If player is struggling, reduce difficulty
      else if (performanceScore < 0.7) {
        Object.keys(scaledWave).forEach(enemyType => {
          if (enemyType !== 'elites') {
            scaledWave[enemyType] = Math.max(Math.floor(scaledWave[enemyType] * 0.8), 1);
          }
        });
        // Remove some elite enemies for struggling players
        if (scaledWave.elites && scaledWave.elites.length > 0) {
          scaledWave.elites.pop();
        }
      }
      
      return scaledWave;
    }

    // Update performance metrics
    function updatePerformanceMetrics() {
      // Calculate accuracy based on shots fired vs enemies killed
      const totalShots = gameState.bullets.length + gameState.performanceMetrics.enemiesKilled * 2;
      gameState.performanceMetrics.accuracy = Math.max(
        (gameState.performanceMetrics.enemiesKilled / Math.max(totalShots, 1)) * 100, 10
      );
      
      // Calculate efficiency based on resources spent vs enemies killed
      const resourcesSpent = 150 - gameState.resources + gameState.performanceMetrics.enemiesKilled * 5;
      gameState.performanceMetrics.efficiency = Math.min(
        (gameState.performanceMetrics.enemiesKilled * 10 / Math.max(resourcesSpent, 1)) * 100, 200
      );
    }

    // Supply convoy system
    function spawnSupplyConvoy() {
      const currentTime = Date.now();
      
      // Spawn convoy every 45-60 seconds
      if (currentTime - gameState.lastConvoyTime > 45000 + Math.random() * 15000) {
        gameState.lastConvoyTime = currentTime;
        
        const convoy = document.createElement('div');
        convoy.className = 'supply-convoy';
        convoy.textContent = 'üöõ';
        
        // Start from a random edge
        const startSide = Math.floor(Math.random() * 4);
        let startX, startY, targetX, targetY;
        
        switch (startSide) {
          case 0: // Top
            startX = Math.random() * 800;
            startY = -30;
            targetX = Math.random() * 800;
            targetY = 530;
            break;
          case 1: // Right
            startX = 830;
            startY = Math.random() * 500;
            targetX = -30;
            targetY = Math.random() * 500;
            break;
          case 2: // Bottom
            startX = Math.random() * 800;
            startY = 530;
            targetX = Math.random() * 800;
            targetY = -30;
            break;
          case 3: // Left
            startX = -30;
            startY = Math.random() * 500;
            targetX = 830;
            targetY = Math.random() * 500;
            break;
        }
        
        convoy.style.left = `${startX}px`;
        convoy.style.top = `${startY}px`;
        gameBoard.appendChild(convoy);
        
        const convoyObj = {
          x: startX, y: startY, targetX, targetY, element: convoy,
          speed: 2, resources: 25 + Math.floor(Math.random() * 25), // 25-50 resources
          health: 15, maxHealth: 15, collected: false
        };
        
        gameState.supplyConvoys.push(convoyObj);
      }
    }

    function updateSupplyConvoys(deltaTime) {
      const convoysToRemove = [];
      
      gameState.supplyConvoys.forEach((convoy, index) => {
        if (convoy.collected) return;
        
        // Move convoy towards target
        const dx = convoy.targetX - convoy.x;
        const dy = convoy.targetY - convoy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          convoy.x += (dx / distance) * convoy.speed * (deltaTime / 16);
          convoy.y += (dy / distance) * convoy.speed * (deltaTime / 16);
          
          convoy.element.style.left = `${convoy.x}px`;
          convoy.element.style.top = `${convoy.y}px`;
        } else {
          // Convoy reached target, remove it
          convoysToRemove.push(index);
        }
        
        // Check if player clicks on convoy to collect resources
        convoy.element.addEventListener('click', () => {
          if (!convoy.collected) {
            convoy.collected = true;
            gameState.resources += convoy.resources;
            updateInfoPanel();
            showResourceGain(convoy.x, convoy.y, convoy.resources);
            convoysToRemove.push(index);
          }
        });
        
        // Convoy can be damaged by enemies
        gameState.enemies.forEach(enemy => {
          const dx = enemy.x - convoy.x;
          const dy = enemy.y - convoy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 25) {
            convoy.health -= enemy.damage;
            if (convoy.health <= 0 && !convoy.collected) {
              convoysToRemove.push(index);
            }
          }
        });
      });
      
      // Remove convoys that have been collected or destroyed
      convoysToRemove.reverse().forEach(index => {
        const convoy = gameState.supplyConvoys[index];
        convoy.element.remove();
        gameState.supplyConvoys.splice(index, 1);
      });
    }

    // Core game functions (unchanged but streamlined)
    function createEnemy(type, isElite) {
      const enemy = document.createElement('div');
      enemy.className = `enemy ${type}${isElite ? ' elite' : ''}`;
      enemy.textContent = enemyTypes[type].icon;
      
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      const healthFill = document.createElement('div');
      healthFill.className = 'health-fill';
      healthBar.appendChild(healthFill);
      enemy.appendChild(healthBar);
      
      gameBoard.appendChild(enemy);
      
      // Apply difficulty and elite modifiers
      const difficultyMod = difficultySettings[gameState.difficulty];
      let health = enemyTypes[type].health * difficultyMod.enemyHealthMultiplier;
      let speed = enemyTypes[type].speed * difficultyMod.enemySpeedMultiplier;
      let worth = Math.floor(enemyTypes[type].worth * difficultyMod.resourceMultiplier);
      let scoreValue = enemyTypes[type].scoreValue;
      
      if (isElite) {
        health *= eliteModifiers.health;
        speed *= eliteModifiers.speed;
        worth *= eliteModifiers.worth;
        scoreValue *= eliteModifiers.scoreValue;
      }
      
      const enemyObj = {
        id: Math.random().toString(36).substr(2, 9),
        x: path[0].x, y: path[0].y,
        type, element: enemy,
        pathIndex: 0, pathProgress: 0,
        health, maxHealth: health, speed, worth,
        damage: enemyTypes[type].damage,
        scoreValue, isElite
      };
      
      enemy.style.left = `${enemyObj.x - enemy.offsetWidth/2}px`;
      enemy.style.top = `${enemyObj.y - enemy.offsetHeight/2}px`;
      
      gameState.enemies.push(enemyObj);
    }

    function fireTower(tower, target) {
      // Calculate firing angle for particle effects and turret rotation
      const dx = target.x - tower.x;
      const dy = target.y - tower.y;
      const angle = Math.atan2(dy, dx);
      
      // Rotate turret to face target
      rotateTowerTurret(tower, angle);
      
      // Add firing animation
      tower.element.classList.add('firing');
      setTimeout(() => {
        tower.element.classList.remove('firing');
      }, 200);
      
      // Create muzzle flash particle effect at barrel tip
      const barrelTipX = tower.x + Math.cos(angle) * 25;
      const barrelTipY = tower.y + Math.sin(angle) * 25;
      ParticleSystem.createMuzzleFlash(barrelTipX, barrelTipY, angle);
      
      // Create muzzle flash lighting effect
      LightingSystem.createMuzzleLight(barrelTipX, barrelTipY, angle);
      
      // Create bullet trail effect
      ParticleSystem.createBulletTrail(tower.x, tower.y, target.x, target.y, tower.type);
      
      // Special effects for artillery
      if (tower.type === 'artillery') {
        ParticleSystem.createArtilleryShell(tower.x, tower.y, target.x, target.y);
        LightingSystem.createShellLight(tower.x, tower.y);
      }
      
      const bullet = document.createElement('div');
      bullet.className = `bullet ${tower.type}`;
      gameBoard.appendChild(bullet);
      
      const bulletObj = {
        x: tower.x, y: tower.y,
        targetX: target.x, targetY: target.y,
        element: bullet, damage: tower.damage,
        distance: 0, maxDistance: tower.range * 1.2,
        type: tower.type
      };
      
      bullet.style.left = `${bulletObj.x - 3}px`;
      bullet.style.top = `${bulletObj.y - 3}px`;
      
      gameState.bullets.push(bulletObj);
    }
    
    // Rotate tower turret to face target
    function rotateTowerTurret(tower, angle) {
      if (tower.turret && tower.type !== 'radar') { // Don't interrupt radar rotation
        const degrees = (angle * 180 / Math.PI) + 90; // Convert to degrees and adjust
        tower.turret.style.transform = `rotate(${degrees}deg)`;
        tower.currentRotation = degrees;
      }
    }
    
    // Add idle animations to active towers
    function updateTowerAnimations() {
      gameState.towers.forEach(tower => {
        // Add active class to towers with targets
        const hasTarget = findTarget(tower) !== null;
        if (hasTarget && !tower.element.classList.contains('active')) {
          tower.element.classList.add('active');
        } else if (!hasTarget && tower.element.classList.contains('active')) {
          tower.element.classList.remove('active');
        }
      });
    }

    function startReloading(tower) {
      tower.reloading = true;
      tower.reloadStart = Date.now();
      tower.element.style.opacity = '0.7';
    }

    function createExplosion(x, y, damage) {
      // Create particle explosion effects
      ParticleSystem.createExplosionParticles(x, y, Math.min(damage * 2, 12));
      
      // Create explosion lighting effect
      const lightIntensity = Math.min(damage / 3, 2.5);
      LightingSystem.createExplosionLight(x, y, lightIntensity);
      
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = `${x}px`;
      explosion.style.top = `${y}px`;
      gameBoard.appendChild(explosion);
      
      gameState.enemies.forEach(enemy => {
        const dx = enemy.x - x;
        const dy = enemy.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= 60) {
          const damageMultiplier = 1 - (distance / 60);
          const splashDamage = Math.round(damage * damageMultiplier);
          if (splashDamage > 0) {
            damageEnemy(enemy, splashDamage);
          }
        }
      });
      
      setTimeout(() => explosion.remove(), 500);
    }

    function damageEnemy(enemy, damage) {
      enemy.health -= damage;
      
      const healthFill = enemy.element.querySelector('.health-fill');
      healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
      
      if (enemy.health <= 0) {
        gameState.resources += enemy.worth;
        gameState.score += enemy.scoreValue;
        gameState.performanceMetrics.enemiesKilled++;
        updateInfoPanel();
        updatePerformanceMetrics();
        removeEnemy(enemy);
      }
    }

    function removeEnemy(enemy) {
      enemy.element.remove();
      const index = gameState.enemies.findIndex(e => e.id === enemy.id);
      if (index !== -1) {
        gameState.enemies.splice(index, 1);
      }
    }

    function checkWaveStatus() {
      if (gameState.waveInProgress && gameState.enemies.length === 0) {
        gameState.waveInProgress = false;
        gameState.currentWave++;
        gameState.performanceMetrics.wavesCompleted++;
        updatePerformanceMetrics();
        
        if (gameState.currentWave >= gameState.maxWaves) {
          endGame(true);
        } else {
          startButton.disabled = false;
          startButton.textContent = `Start Wave ${gameState.currentWave + 1}`;
        }
        
        updateInfoPanel();
      }
    }

    function updateInfoPanel() {
      waveInfoElement.textContent = `Wave: ${gameState.currentWave}/${gameState.maxWaves}`;
      resourcesElement.textContent = `Resources: ${Math.floor(gameState.resources)}`;
      livesElement.textContent = `Base Health: ${gameState.lives}/20`;
      scoreElement.textContent = `Score: ${gameState.score}`;
    }

    function endGame(victory) {
      if (victory) {
        gameState.victory = true;
        levelCompletePanel.style.display = 'block';
        victoryScoreElement.textContent = gameState.score;
      } else {
        gameState.gameOver = true;
        gameOverPanel.style.display = 'block';
        finalScoreElement.textContent = gameState.score;
      }
      
      closeUpgradePanel();
      cancelAnimationFrame(gameState.animationFrameId);
    }

    function restartGame() {
      // Clear game elements
      gameState.enemies.forEach(enemy => enemy.element.remove());
      gameState.towers.forEach(tower => tower.element.remove());
      gameState.bullets.forEach(bullet => bullet.element.remove());
      gameState.terrainElements.forEach(element => element.remove());
      gameState.walls.forEach(wall => wall.element.remove());
      gameState.mines.forEach(mine => mine.element.remove());
      gameState.supplyConvoys.forEach(convoy => convoy.element.remove());
      ParticleSystem.clearAllParticles();
      LightingSystem.clearAllLights();
      WeatherSystem.clearWeatherEffects();
      gameState.terrainElements = [];
      
      // Reset game state
      Object.assign(gameState, {
        resources: 150, lives: 20, currentWave: 0, waveInProgress: false,
        gameOver: false, victory: false, selectedTowerType: null, selectedTower: null,
        towers: [], enemies: [], bullets: [], animationFrameId: null,
        score: 0, lastFrameTime: 0, frameCounter: 0, enemySpeedMultiplier: 0.4,
        walls: [], mines: [], radarCoverage: false, nextWavePreview: null, supplyConvoys: [],
        lastConvoyTime: 0, weather: { type: 'clear', intensity: 0, lastChange: 0 },
        performanceMetrics: { enemiesKilled: 0, wavesCompleted: 0, accuracy: 100, efficiency: 100 }
      });
      
      // Reset UI
      startButton.disabled = false;
      startButton.textContent = 'Start Wave 1';
      gameOverPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      upgradePanel.style.display = 'none';
      document.querySelectorAll('.tower-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      // Reinitialize game with new map
      generateMapData(); // Generate new random map
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
    }

    // Generate a new map without resetting the game
    function generateNewMap() {
      if (gameState.waveInProgress) {
        alert("Cannot generate new map during a wave!");
        return;
      }
      
      // Clear existing map elements
      gameState.terrainElements.forEach(element => element.remove());
      gameState.terrainElements = [];
      
      // Clear existing path visualization
      document.querySelectorAll('.path').forEach(path => path.remove());
      
      // Generate new map
      generateMapData();
      createPathVisualization();
      addTerrainElements();
    }

    // Utility functions
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Initialize the game
    initGame();
  </script>
</body>
</html>