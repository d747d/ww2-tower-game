<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WWII Tower Defense - Improved</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Courier New', monospace;
      background-color: #222;
      color: #fff;
      overflow-x: hidden;
    }
    #game-container {
      position: relative;
      width: 800px;
      height: 500px;
      margin: 20px auto;
      background-color: #3d4c2e; /* Military green background */
      border: 3px solid #8b7d39;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
      overflow: hidden;
    }
    #game-board {
      position: relative;
      width: 100%;
      height: 100%;
    }
    .path {
      position: absolute;
      background-color: rgba(139, 69, 19, 0.7);
      border: 1px dashed #a58d68;
      pointer-events: none;
    }
    #vertical-path1 {
      width: 60px;
      height: 330px;
      top: 0;
      left: 200px;
    }
    #horizontal-path1 {
      width: 200px;
      height: 60px;
      top: 330px;
      left: 200px;
    }
    #vertical-path2 {
      width: 60px;
      height: 150px;
      top: 180px;
      left: 400px;
    }
    #horizontal-path2 {
      width: 200px;
      height: 60px;
      top: 180px;
      left: 400px;
    }
    #info-panel {
      width: 800px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background-color: #3a3a3a;
      border: 3px solid #8b7d39;
      border-top: none;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }
    #tower-selection {
      display: flex;
      gap: 10px;
    }
    .tower-option {
      width: 60px;
      height: 60px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 2px solid #777;
      border-radius: 5px;
      background-color: #444;
      transition: all 0.2s;
    }
    .tower-option:hover {
      background-color: #555;
      transform: translateY(-3px);
    }
    .tower-option.selected {
      border-color: #ffcc00;
      box-shadow: 0 0 10px #ffcc00;
    }
    .tower-icon {
      font-size: 24px;
      margin-bottom: 5px;
    }
    .tower-cost {
      font-size: 12px;
      font-weight: bold;
      color: #ffcc00;
    }
    .tower {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 10;
      font-size: 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }
    .tower:hover {
      box-shadow: 0 0 8px 3px #ffcc00;
    }
    .tower.mg {
      background-color: #3a3a3a;
      border: 2px solid #6e6e6e;
    }
    .tower.artillery {
      background-color: #2d572c;
      border: 2px solid #4a7b49;
    }
    .tower.aa {
      background-color: #1a3e5c;
      border: 2px solid #3a6da3;
    }
    .tower.sniper {
      background-color: #5c2b1a;
      border: 2px solid #8a4f3b;
    }
    .tower-range {
      position: absolute;
      border-radius: 50%;
      background-color: rgba(255, 240, 130, 0.15);
      border: 1px dashed rgba(255, 204, 0, 0.3);
      pointer-events: none;
      z-index: 5;
      display: none;
    }
    .bullet {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      z-index: 8;
    }
    .bullet.mg {
      background-color: #ffcc00;
    }
    .bullet.artillery {
      background-color: #ff6600;
      width: 8px;
      height: 8px;
    }
    .bullet.aa {
      background-color: #00ccff;
    }
    .bullet.sniper {
      background-color: #ff0000;
      width: 4px;
      height: 10px;
    }
    .explosion {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,102,0,0.8) 0%, rgba(255,153,0,0.6) 40%, rgba(255,204,0,0.2) 70%, rgba(255,204,0,0) 100%);
      z-index: 8;
      transform: translate(-50%, -50%);
      animation: explode 0.5s forwards;
    }
    @keyframes explode {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
    }
    .enemy {
      position: absolute;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      z-index: 9;
      border-radius: 3px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }
    .enemy.infantry {
      background-color: #8b0000;
      border: 1px solid #ff0000;
    }
    .enemy.tank {
      background-color: #b22222;
      width: 35px;
      height: 35px;
      border: 1px solid #ff3333;
    }
    .enemy.heavytank {
      background-color: #8b4500;
      width: 40px;
      height: 40px;
      border: 1px solid #ff7700;
    }
    .enemy.aircraft {
      background-color: #4b0082;
      border: 1px solid #9370db;
    }
    .enemy.elite {
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .health-bar {
      position: absolute;
      width: 30px;
      height: 4px;
      background-color: #333;
      top: -8px;
      left: 0;
      border-radius: 2px;
      overflow: hidden;
    }
    .health-fill {
      height: 100%;
      background-color: #32cd32;
      width: 100%;
      transition: width 0.2s;
    }
    #start-button {
      padding: 8px 15px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s;
    }
    #start-button:hover {
      background-color: #3e8e41;
    }
    #start-button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    #wave-info, #resources, #lives, #score-display {
      font-size: 16px;
      padding: 5px 10px;
      background-color: rgba(0, 0, 0, 0.3);
      border-radius: 5px;
      margin-right: 10px;
    }
    #wave-info {
      color: #ffcc00;
    }
    #resources {
      color: #32cd32;
    }
    #lives {
      color: #ff6666;
    }
    #score-display {
      color: #66ccff;
    }
    #game-over, #level-complete {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.85);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 100;
      border: 3px solid #8b7d39;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
      width: 300px;
    }
    .game-over-title {
      color: #ff6666;
      margin-top: 0;
      font-size: 28px;
    }
    .victory-title {
      color: #32cd32;
      margin-top: 0;
      font-size: 28px;
    }
    .final-score {
      font-size: 20px;
      margin: 15px 0;
      color: #ffcc00;
    }
    button.restart {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      margin-top: 15px;
      cursor: pointer;
      font-size: 16px;
    }
    button.restart:hover {
      background-color: #3e8e41;
    }
    #instructions {
      width: 800px;
      margin: 10px auto;
      background-color: #3a3a3a;
      padding: 15px;
      border: 3px solid #8b7d39;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .difficulty-selection {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .difficulty-btn {
      padding: 8px 15px;
      background-color: #555;
      border: none;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      flex: 1;
    }
    .difficulty-btn:hover {
      background-color: #666;
    }
    .difficulty-btn.selected {
      background-color: #4CAF50;
      font-weight: bold;
    }
    .upgrade-panel {
      display: none;
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      border: 2px solid #ffcc00;
      border-radius: 5px;
      padding: 10px;
      z-index: 20;
      width: 150px;
    }
    .upgrade-option {
      margin-bottom: 8px;
      cursor: pointer;
      padding: 5px;
      background-color: #444;
      border-radius: 3px;
    }
    .upgrade-option:hover {
      background-color: #555;
    }
    .upgrade-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .close-panel {
      position: absolute;
      top: 5px;
      right: 8px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    }
    .ammo-bar {
      position: absolute;
      bottom: -8px;
      left: 0;
      width: 30px;
      height: 3px;
      background-color: #333;
      border-radius: 1px;
      overflow: hidden;
    }
    .ammo-fill {
      height: 100%;
      background-color: #ffaa00;
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2 style="margin-top: 0;">WWII Tower Defense - Improved</h2>
    <p>Select a tower, place it on the map (avoiding the path), and defend against waves of enemies!</p>
    <p><strong>Towers:</strong></p>
    <p>Machine Gun (üë®‚Äçü¶Ø) - good against infantry, Artillery (üí£) - area damage, Anti-Air (‚ö°) - counters aircraft, Sniper (üî≠) - high damage</p>
    <div class="difficulty-selection">
      <button class="difficulty-btn selected" data-difficulty="normal">Normal</button>
      <button class="difficulty-btn" data-difficulty="hard">Hard</button>
      <button class="difficulty-btn" data-difficulty="veteran">Veteran</button>
    </div>
  </div>
  
  <div id="game-container">
    <div id="game-board">
      <div id="vertical-path1" class="path"></div>
      <div id="horizontal-path1" class="path"></div>
      <div id="vertical-path2" class="path"></div>
      <div id="horizontal-path2" class="path"></div>
    </div>
    <div id="game-over">
      <h2 class="game-over-title">Game Over!</h2>
      <p>Your base was overrun!</p>
      <div class="final-score">Final Score: <span id="final-score">0</span></div>
      <button class="restart" onclick="restartGame()">Try Again</button>
    </div>
    <div id="level-complete">
      <h2 class="victory-title">Victory!</h2>
      <p>You successfully defended your position!</p>
      <div class="final-score">Final Score: <span id="victory-score">0</span></div>
      <button class="restart" onclick="restartGame()">Play Again</button>
    </div>
  </div>
  
  <div id="info-panel">
    <div style="display: flex;">
      <div id="wave-info">Wave: 0/12</div>
      <div id="resources">Resources: 150</div>
      <div id="lives">Base Health: 20/20</div>
      <div id="score-display">Score: 0</div>
    </div>
    <div id="tower-selection">
      <div class="tower-option" data-type="mg" onclick="selectTower('mg')">
        <div class="tower-icon">üë®‚Äçü¶Ø</div>
        <div class="tower-cost">$25</div>
      </div>
      <div class="tower-option" data-type="artillery" onclick="selectTower('artillery')">
        <div class="tower-icon">üí£</div>
        <div class="tower-cost">$50</div>
      </div>
      <div class="tower-option" data-type="aa" onclick="selectTower('aa')">
        <div class="tower-icon">‚ö°</div>
        <div class="tower-cost">$40</div>
      </div>
      <div class="tower-option" data-type="sniper" onclick="selectTower('sniper')">
        <div class="tower-icon">üî≠</div>
        <div class="tower-cost">$60</div>
      </div>
    </div>
    <button id="start-button" onclick="startWave()">Start Wave 1</button>
  </div>

  <div class="upgrade-panel" id="upgrade-panel">
    <div class="close-panel" onclick="closeUpgradePanel()">‚úï</div>
    <div class="upgrade-option" id="upgrade-damage" onclick="upgradeTower('damage')">
      Damage +25% ($30)
    </div>
    <div class="upgrade-option" id="upgrade-range" onclick="upgradeTower('range')">
      Range +15% ($25)
    </div>
    <div class="upgrade-option" id="upgrade-rate" onclick="upgradeTower('rate')">
      Fire Rate +20% ($35)
    </div>
  </div>

  <script>
    // Game state
    const gameState = {
      resources: 150,
      lives: 20,
      currentWave: 0,
      maxWaves: 12,
      waveInProgress: false,
      gameOver: false,
      victory: false,
      score: 0,
      selectedTowerType: null,
      selectedTower: null,
      towers: [],
      enemies: [],
      bullets: [],
      enemyCounter: 0,
      lastTime: 0,
      animationFrameId: null,
      difficulty: 'normal'
    };

    // Tower definitions
    const towerTypes = {
      mg: {
        name: "Machine Gun",
        cost: 25,
        damage: 1,
        range: 120,
        fireRate: 500,
        targets: ["infantry", "tank", "heavytank"],
        icon: "üë®‚Äçü¶Ø",
        ammo: 20,
        maxAmmo: 20,
        reloadTime: 2000
      },
      artillery: {
        name: "Artillery",
        cost: 50,
        damage: 3,
        range: 180,
        fireRate: 2000,
        targets: ["infantry", "tank", "heavytank"],
        icon: "üí£",
        splash: 60,
        ammo: 3,
        maxAmmo: 3,
        reloadTime: 5000
      },
      aa: {
        name: "Anti-Air",
        cost: 40,
        damage: 2,
        range: 150,
        fireRate: 800,
        targets: ["aircraft"],
        icon: "‚ö°",
        ammo: 15,
        maxAmmo: 15,
        reloadTime: 3000
      },
      sniper: {
        name: "Sniper",
        cost: 60,
        damage: 6,
        range: 250,
        fireRate: 3000,
        targets: ["infantry", "tank", "heavytank"],
        icon: "üî≠",
        ammo: 5,
        maxAmmo: 5,
        reloadTime: 4000
      }
    };

    // Enemy definitions
    const enemyTypes = {
      infantry: {
        name: "Infantry",
        health: 3,
        speed: 1,
        worth: 5,
        damage: 1,
        icon: "üë§",
        scoreValue: 10
      },
      tank: {
        name: "Tank",
        health: 8,
        speed: 0.5,
        worth: 10,
        damage: 2,
        icon: "üöú",
        scoreValue: 25
      },
      heavytank: {
        name: "Heavy Tank",
        health: 20,
        speed: 0.3,
        worth: 20,
        damage: 4,
        icon: "üöõ",
        scoreValue: 50
      },
      aircraft: {
        name: "Aircraft",
        health: 4,
        speed: 1.5,
        worth: 8,
        damage: 1,
        icon: "‚úàÔ∏è",
        scoreValue: 20
      }
    };

    // Elite enemy modifiers
    const eliteModifiers = {
      health: 2,     // 2x health
      speed: 1.2,    // 20% faster
      worth: 2,      // 2x resources
      scoreValue: 2  // 2x score
    };

    // Wave definitions
    const waveDefinitions = [
      { infantry: 10 },
      { infantry: 15, tank: 2 },
      { infantry: 10, aircraft: 5 },
      { infantry: 15, tank: 5 },
      { infantry: 10, tank: 5, aircraft: 5 },
      { infantry: 20, tank: 8 },
      { heavytank: 2, infantry: 10, aircraft: 8 },
      { infantry: 15, tank: 5, aircraft: 10 },
      { infantry: 15, tank: 10, aircraft: 5, heavytank: 2 },
      { infantry: 20, tank: 10, aircraft: 10 },
      { infantry: 25, tank: 15, aircraft: 10, elites: ["tank"] },
      { infantry: 30, tank: 20, aircraft: 15, heavytank: 10, elites: ["heavytank", "aircraft"] }
    ];

    // Difficulty settings
    const difficultySettings = {
      normal: {
        enemyHealthMultiplier: 1,
        enemySpeedMultiplier: 1,
        resourceMultiplier: 1,
        waveSpawnDelay: 800
      },
      hard: {
        enemyHealthMultiplier: 1.5,
        enemySpeedMultiplier: 1.2,
        resourceMultiplier: 0.8,
        waveSpawnDelay: 600
      },
      veteran: {
        enemyHealthMultiplier: 2,
        enemySpeedMultiplier: 1.4,
        resourceMultiplier: 0.6,
        waveSpawnDelay: 400
      }
    };

    // Path for enemies (more complex path)
    const path = [
      { x: 230, y: -30 },        // Start above the screen
      { x: 230, y: 330 },        // Down the vertical path
      { x: 400, y: 330 },        // Right along the first horizontal path
      { x: 400, y: 180 },        // Up the second vertical path
      { x: 600, y: 180 }         // Right along the second horizontal path
    ];

    // DOM Elements
    const gameBoard = document.getElementById('game-board');
    const waveInfoElement = document.getElementById('wave-info');
    const resourcesElement = document.getElementById('resources');
    const livesElement = document.getElementById('lives');
    const scoreElement = document.getElementById('score-display');
    const startButton = document.getElementById('start-button');
    const gameOverPanel = document.getElementById('game-over');
    const levelCompletePanel = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const victoryScoreElement = document.getElementById('victory-score');
    const upgradePanel = document.getElementById('upgrade-panel');

    // Initialize the game
    updateInfoPanel();

    // Set up difficulty selection
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
        this.classList.add('selected');
        gameState.difficulty = this.getAttribute('data-difficulty');
      });
    });

    // Event listener for tower placement
    gameBoard.addEventListener('click', function(event) {
      if (gameState.selectedTowerType) {
        const rect = gameBoard.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        placeTower(x, y);
      }
    });

    // Game loop
    function gameLoop(timestamp) {
      if (!gameState.lastTime) {
        gameState.lastTime = timestamp;
      }
      
      const deltaTime = timestamp - gameState.lastTime;
      gameState.lastTime = timestamp;

      if (!gameState.gameOver && !gameState.victory) {
        updateGame(deltaTime);
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function updateGame(deltaTime) {
      // Move enemies
      moveEnemies(deltaTime);
      
      // Tower firing logic
      checkTowerFiring();
      
      // Move bullets
      updateBullets(deltaTime);
      
      // Check wave status
      checkWaveStatus();
      
      // Check tower reloading
      checkTowerReloading();
    }

    function moveEnemies(deltaTime) {
      for (let i = gameState.enemies.length - 1; i >= 0; i--) {
        const enemy = gameState.enemies[i];
        
        if (enemy.pathSegment >= path.length - 1) {
          // Enemy reached the end
          gameState.lives -= enemy.damage;
          updateInfoPanel();
          removeEnemy(enemy);
          
          // Check if game over
          if (gameState.lives <= 0) {
            endGame(false);
          }
          continue;
        }
        
        // Get current and next path points
        const currentPoint = path[enemy.pathSegment];
        const nextPoint = path[enemy.pathSegment + 1];
        
        // Calculate direction
        const dx = nextPoint.x - currentPoint.x;
        const dy = nextPoint.y - currentPoint.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate movement for this frame
        const speedFactor = enemy.speed * (deltaTime / 16);
        const moveX = (dx / distance) * speedFactor;
        const moveY = (dy / distance) * speedFactor;
        
        // Update position
        enemy.x += moveX;
        enemy.y += moveY;
        
        // Update visual position
        enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
        enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
        
        // Check if reached next point
        const distTraveled = Math.sqrt(
          Math.pow(enemy.x - currentPoint.x, 2) + 
          Math.pow(enemy.y - currentPoint.y, 2)
        );
        
        if (distTraveled >= distance) {
          enemy.pathSegment++;
        }
      }
    }

    function checkTowerFiring() {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        // Check if tower is reloading
        if (tower.reloading) return;
        
        // Check if tower has ammo
        if (tower.ammo <= 0) {
          startReloading(tower);
          return;
        }
        
        if (currentTime - tower.lastFired < tower.fireRate) {
          return;
        }
        
        const target = findTarget(tower);
        if (target) {
          fireTower(tower, target);
          tower.lastFired = currentTime;
          tower.ammo--;
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = `${(tower.ammo / tower.maxAmmo) * 100}%`;
          }
        }
      });
    }

    function checkTowerReloading() {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        if (tower.reloading && currentTime - tower.reloadStart >= tower.reloadTime) {
          tower.reloading = false;
          tower.ammo = tower.maxAmmo;
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = '100%';
          }
        }
      });
    }

    function startReloading(tower) {
      tower.reloading = true;
      tower.reloadStart = Date.now();
      
      // Visual indication of reloading
      tower.element.style.opacity = '0.7';
      
      // Reset after reload
      setTimeout(() => {
        tower.element.style.opacity = '1';
      }, tower.reloadTime);
    }

    function updateBullets(deltaTime) {
      for (let i = gameState.bullets.length - 1; i >= 0; i--) {
        const bullet = gameState.bullets[i];
        
        // Move bullet
        const moveSpeed = 0.4 * deltaTime;
        const dx = bullet.targetX - bullet.x;
        const dy = bullet.targetY - bullet.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          bullet.x += (dx / distance) * moveSpeed;
          bullet.y += (dy / distance) * moveSpeed;
          bullet.distance += moveSpeed;
        }
        
        bullet.element.style.left = `${bullet.x - 3}px`;
        bullet.element.style.top = `${bullet.y - 3}px`;
        
        // Check for hits
        if (bullet.type === 'artillery' && bullet.distance >= bullet.maxDistance * 0.9) {
          // Artillery explosion at target
          createExplosion(bullet.targetX, bullet.targetY, bullet.damage);
          bullet.element.remove();
          gameState.bullets.splice(i, 1);
          continue;
        }
        
        let hitEnemy = null;
        
        // Normal bullet hit detection
        for (let j = 0; j < gameState.enemies.length; j++) {
          const enemy = gameState.enemies[j];
          const hitDx = enemy.x - bullet.x;
          const hitDy = enemy.y - bullet.y;
          const hitDistance = Math.sqrt(hitDx * hitDx + hitDy * hitDy);
          
          if (hitDistance < 15) {
            hitEnemy = enemy;
            break;
          }
        }
        
        // Handle bullet hit or remove if out of range
        if (hitEnemy) {
          // Apply damage
          damageEnemy(hitEnemy, bullet.damage);
          
          // Remove bullet
          bullet.element.remove();
          gameState.bullets.splice(i, 1);
        } 
        else if (bullet.distance > bullet.maxDistance) {
          // Bullet out of range
          bullet.element.remove();
          gameState.bullets.splice(i, 1);
        }
      }
    }

    function createExplosion(x, y, damage) {
      // Create explosion element
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = `${x}px`;
      explosion.style.top = `${y}px`;
      gameBoard.appendChild(explosion);
      
      // Damage enemies in blast radius
      gameState.enemies.forEach(enemy => {
        const dx = enemy.x - x;
        const dy = enemy.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= 60) {  // Artillery splash radius
          // Damage falls off with distance
          const damageMultiplier = 1 - (distance / 60);
          const splashDamage = Math.round(damage * damageMultiplier);
          
          if (splashDamage > 0) {
            damageEnemy(enemy, splashDamage);
          }
        }
      });
      
      // Remove explosion after animation
      setTimeout(() => {
        explosion.remove();
      }, 500);
    }

    function damageEnemy(enemy, damage) {
      enemy.health -= damage;
      
      // Update health bar
      const healthFill = enemy.element.querySelector('.health-fill');
      const healthPercentage = (enemy.health / enemy.maxHealth) * 100;
      healthFill.style.width = `${healthPercentage}%`;
      
      // Check if enemy is destroyed
      if (enemy.health <= 0) {
        // Add resources and score
        gameState.resources += enemy.worth;
        gameState.score += enemy.scoreValue;
        updateInfoPanel();
        removeEnemy(enemy);
      }
    }

    function checkWaveStatus() {
      if (gameState.waveInProgress && gameState.enemies.length === 0) {
        gameState.waveInProgress = false;
        gameState.currentWave++;
        
        if (gameState.currentWave >= gameState.maxWaves) {
          // Victory!
          endGame(true);
        } else {
          // Prepare for next wave
          startButton.disabled = false;
          startButton.textContent = `Start Wave ${gameState.currentWave + 1}`;
        }
        
        updateInfoPanel();
      }
    }

    function findTarget(tower) {
      let closestEnemy = null;
      let closestDistance = Infinity;
      
      gameState.enemies.forEach(enemy => {
        // Check if this tower can target this enemy type
        if (!tower.targets.includes(enemy.type)) {
          return;
        }
        
        // Check if in range
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= tower.range && distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      return closestEnemy;
    }

    function fireTower(tower, target) {
      // Create bullet element
      const bullet = document.createElement('div');
      bullet.className = `bullet ${tower.type}`;
      gameBoard.appendChild(bullet);
      
      // Create bullet object
      const bulletObj = {
        x: tower.x,
        y: tower.y,
        targetX: target.x,
        targetY: target.y,
        element: bullet,
        damage: tower.damage,
        distance: 0,
        maxDistance: tower.range * 1.2,
        type: tower.type
      };
      
      // Set initial position
      bullet.style.left = `${bulletObj.x - 3}px`;
      bullet.style.top = `${bulletObj.y - 3}px`;
      
      gameState.bullets.push(bulletObj);
    }

    function placeTower(x, y) {
      // Check if tower can be placed here
      if (isOnPath(x, y) || isTowerConflict(x, y)) {
        return;
      }
      
      const towerType = towerTypes[gameState.selectedTowerType];
      
      // Check if enough resources
      if (gameState.resources < towerType.cost) {
        return;
      }
      
      // Deduct resources
      gameState.resources -= towerType.cost;
      updateInfoPanel();
      
      // Create tower
      createTower(x, y, gameState.selectedTowerType);
    }

    function isOnPath(x, y) {
      // Check vertical path 1
      if (x >= 200 && x <= 260 && y >= 0 && y <= 330) {
        return true;
      }
      
      // Check horizontal path 1
      if (x >= 200 && x <= 400 && y >= 330 && y <= 390) {
        return true;
      }
      
      // Check vertical path 2
      if (x >= 400 && x <= 460 && y >= 180 && y <= 330) {
        return true;
      }
      
      // Check horizontal path 2
      if (x >= 400 && x <= 600 && y >= 180 && y <= 240) {
        return true;
      }
      
      return false;
    }

    function isTowerConflict(x, y) {
      return gameState.towers.some(tower => {
        const dx = tower.x - x;
        const dy = tower.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 40;
      });
    }

    function createTower(x, y, type) {
      // Create tower element
      const tower = document.createElement('div');
      tower.className = `tower ${type}`;
      tower.textContent = towerTypes[type].icon;
      gameBoard.appendChild(tower);
      
      // Create range indicator
      const range = document.createElement('div');
      range.className = 'tower-range';
      range.style.width = `${towerTypes[type].range * 2}px`;
      range.style.height = `${towerTypes[type].range * 2}px`;
      tower.appendChild(range);
      
      // Create ammo bar
      const ammoBar = document.createElement('div');
      ammoBar.className = 'ammo-bar';
      const ammoFill = document.createElement('div');
      ammoFill.className = 'ammo-fill';
      ammoBar.appendChild(ammoFill);
      tower.appendChild(ammoBar);
      
      // Create tower object
      const towerObj = {
        x: x,
        y: y,
        type: type,
        element: tower,
        lastFired: 0,
        damage: towerTypes[type].damage,
        range: towerTypes[type].range,
        fireRate: towerTypes[type].fireRate,
        targets: towerTypes[type].targets,
        ammo: towerTypes[type].ammo,
        maxAmmo: towerTypes[type].maxAmmo,
        reloadTime: towerTypes[type].reloadTime,
        reloading: false,
        ammoBar: ammoFill,
        level: {
          damage: 1,
          range: 1,
          rate: 1
        }
      };
      
      // Add splash property for artillery
      if (type === 'artillery') {
        towerObj.splash = towerTypes[type].splash;
      }
      
      // Position tower
      tower.style.left = `${x - 20}px`;
      tower.style.top = `${y - 20}px`;
      range.style.left = `-${towerTypes[type].range - 20}px`;
      range.style.top = `-${towerTypes[type].range - 20}px`;
      
      // Add to towers array
      gameState.towers.push(towerObj);
      
      // Show range on hover
      tower.addEventListener('mouseover', function() {
        range.style.display = 'block';
      });
      
      tower.addEventListener('mouseout', function() {
        range.style.display = 'none';
      });
      
      // Handle tower selection for upgrades
      tower.addEventListener('click', function(event) {
        event.stopPropagation();
        selectTowerForUpgrade(towerObj);
      });
    }

    function selectTowerForUpgrade(tower) {
      gameState.selectedTower = tower;
      
      // Update upgrade panel
      document.getElementById('upgrade-damage').textContent = 
        `Damage +25% ($${30 * tower.level.damage})`;
      document.getElementById('upgrade-range').textContent = 
        `Range +15% ($${25 * tower.level.range})`;
      document.getElementById('upgrade-rate').textContent = 
        `Fire Rate +20% ($${35 * tower.level.rate})`;
      
      // Position upgrade panel near the tower
      const upgradePanel = document.getElementById('upgrade-panel');
      upgradePanel.style.left = `${tower.x + 30}px`;
      upgradePanel.style.top = `${tower.y - 50}px`;
      upgradePanel.style.display = 'block';
      
      // Check if upgrades should be disabled based on resources
      if (gameState.resources < 30 * tower.level.damage) {
        document.getElementById('upgrade-damage').classList.add('disabled');
      } else {
        document.getElementById('upgrade-damage').classList.remove('disabled');
      }
      
      if (gameState.resources < 25 * tower.level.range) {
        document.getElementById('upgrade-range').classList.add('disabled');
      } else {
        document.getElementById('upgrade-range').classList.remove('disabled');
      }
      
      if (gameState.resources < 35 * tower.level.rate) {
        document.getElementById('upgrade-rate').classList.add('disabled');
      } else {
        document.getElementById('upgrade-rate').classList.remove('disabled');
      }
    }

    function closeUpgradePanel() {
      document.getElementById('upgrade-panel').style.display = 'none';
      gameState.selectedTower = null;
    }

    function upgradeTower(upgradeType) {
      if (!gameState.selectedTower) return;
      
      const tower = gameState.selectedTower;
      let cost = 0;
      
      switch (upgradeType) {
        case 'damage':
          cost = 30 * tower.level.damage;
          if (gameState.resources >= cost) {
            tower.damage *= 1.25;
            tower.level.damage++;
          }
          break;
        case 'range':
          cost = 25 * tower.level.range;
          if (gameState.resources >= cost) {
            tower.range *= 1.15;
            tower.level.range++;
            
            // Update range indicator
            const rangeIndicator = tower.element.querySelector('.tower-range');
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
          break;
        case 'rate':
          cost = 35 * tower.level.rate;
          if (gameState.resources >= cost) {
            tower.fireRate *= 0.8;
            tower.level.rate++;
          }
          break;
      }
      
      if (cost && gameState.resources >= cost) {
        gameState.resources -= cost;
        updateInfoPanel();
        
        // Visual feedback for upgrade
        tower.element.style.transform = 'scale(1.3)';
        setTimeout(() => {
          tower.element.style.transform = 'scale(1)';
        }, 300);
        
        // Close and reopen to refresh costs
        closeUpgradePanel();
        selectTowerForUpgrade(tower);
      }
    }

    function selectTower(type) {
      // Close upgrade panel if open
      closeUpgradePanel();
      
      // Deselect all tower options
      document.querySelectorAll('.tower-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      // Select the clicked tower option
      document.querySelector(`.tower-option[data-type="${type}"]`).classList.add('selected');
      
      // Set selected tower type
      gameState.selectedTowerType = type;
    }

    function startWave() {
      if (gameState.waveInProgress) return;
      
      gameState.waveInProgress = true;
      startButton.disabled = true;
      startButton.textContent = 'Wave in Progress';
      
      const waveDefinition = waveDefinitions[gameState.currentWave];
      
      // Spawn enemies in this wave
      spawnEnemies(waveDefinition);
      
      // Start game loop if not already running
      if (gameState.animationFrameId === null) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function spawnEnemies(waveDefinition) {
      let delay = 0;
      const spawnDelay = difficultySettings[gameState.difficulty].waveSpawnDelay;
      
      // Create a list of enemies to spawn
      const enemiesToSpawn = [];
      
      // Add normal enemies
      for (const [type, count] of Object.entries(waveDefinition)) {
        if (type !== 'elites') {
          for (let i = 0; i < count; i++) {
            enemiesToSpawn.push(type);
          }
        }
      }
      
      // Add elite enemies
      if (waveDefinition.elites) {
        waveDefinition.elites.forEach(eliteType => {
          // Add 2-3 elite enemies of this type
          const eliteCount = Math.floor(Math.random() * 2) + 2;
          for (let i = 0; i < eliteCount; i++) {
            enemiesToSpawn.push(`elite_${eliteType}`);
          }
        });
      }
      
      // Shuffle the enemies array for mixed spawning
      shuffleArray(enemiesToSpawn);
      
      // Spawn enemies with delay
      enemiesToSpawn.forEach(enemyType => {
        setTimeout(() => {
          if (!gameState.gameOver && !gameState.victory) {
            if (enemyType.includes('elite_')) {
              createEnemy(enemyType.split('_')[1], true);
            } else {
              createEnemy(enemyType, false);
            }
          }
        }, delay);
        delay += spawnDelay;
      });
    }

    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function createEnemy(type, isElite) {
      // Create enemy element
      const enemy = document.createElement('div');
      enemy.className = `enemy ${type}`;
      if (isElite) {
        enemy.classList.add('elite');
      }
      enemy.textContent = enemyTypes[type].icon;
      
      // Create health bar
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      const healthFill = document.createElement('div');
      healthFill.className = 'health-fill';
      healthBar.appendChild(healthFill);
      enemy.appendChild(healthBar);
      
      gameBoard.appendChild(enemy);
      
      // Set starting position at beginning of path
      const startPoint = path[0];
      
      // Apply difficulty modifiers
      const difficultyMod = difficultySettings[gameState.difficulty];
      
      // Calculate health and other stats
      let health = enemyTypes[type].health * difficultyMod.enemyHealthMultiplier;
      let speed = enemyTypes[type].speed * difficultyMod.enemySpeedMultiplier;
      let worth = Math.floor(enemyTypes[type].worth * difficultyMod.resourceMultiplier);
      let scoreValue = enemyTypes[type].scoreValue;
      
      // Apply elite modifiers if applicable
      if (isElite) {
        health *= eliteModifiers.health;
        speed *= eliteModifiers.speed;
        worth *= eliteModifiers.worth;
        scoreValue *= eliteModifiers.scoreValue;
      }
      
      // Create enemy object
      const enemyObj = {
        id: gameState.enemyCounter++,
        x: startPoint.x,
        y: startPoint.y,
        type: type,
        element: enemy,
        pathSegment: 0,
        health: health,
        maxHealth: health,
        speed: speed,
        worth: worth,
        damage: enemyTypes[type].damage,
        scoreValue: scoreValue,
        isElite: isElite
      };
      
      // Position the enemy
      enemy.style.left = `${enemyObj.x - enemy.offsetWidth/2}px`;
      enemy.style.top = `${enemyObj.y - enemy.offsetHeight/2}px`;
      
      // Add to enemies array
      gameState.enemies.push(enemyObj);
    }

    function removeEnemy(enemy) {
      enemy.element.remove();
      const index = gameState.enemies.findIndex(e => e.id === enemy.id);
      if (index !== -1) {
        gameState.enemies.splice(index, 1);
      }
    }

    function updateInfoPanel() {
      waveInfoElement.textContent = `Wave: ${gameState.currentWave}/${gameState.maxWaves}`;
      resourcesElement.textContent = `Resources: ${Math.floor(gameState.resources)}`;
      livesElement.textContent = `Base Health: ${gameState.lives}/20`;
      scoreElement.textContent = `Score: ${gameState.score}`;
    }

    function endGame(victory) {
      if (victory) {
        gameState.victory = true;
        levelCompletePanel.style.display = 'block';
        victoryScoreElement.textContent = gameState.score;
      } else {
        gameState.gameOver = true;
        gameOverPanel.style.display = 'block';
        finalScoreElement.textContent = gameState.score;
      }
      
      closeUpgradePanel();
      cancelAnimationFrame(gameState.animationFrameId);
    }

    function restartGame() {
      // Clear all game elements
      gameState.enemies.forEach(enemy => enemy.element.remove());
      gameState.towers.forEach(tower => tower.element.remove());
      gameState.bullets.forEach(bullet => bullet.element.remove());
      
      // Reset game state
      gameState.resources = 150;
      gameState.lives = 20;
      gameState.currentWave = 0;
      gameState.waveInProgress = false;
      gameState.gameOver = false;
      gameState.victory = false;
      gameState.selectedTowerType = null;
      gameState.selectedTower = null;
      gameState.towers = [];
      gameState.enemies = [];
      gameState.bullets = [];
      gameState.score = 0;
      gameState.enemyCounter = 0;
      gameState.lastTime = 0;
      gameState.animationFrameId = null;
      
      // Reset UI
      startButton.disabled = false;
      startButton.textContent = 'Start Wave 1';
      gameOverPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      upgradePanel.style.display = 'none';
      document.querySelectorAll('.tower-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      // Update info panel
      updateInfoPanel();
    }
  </script>
</body>
</html>