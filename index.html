<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WWII Tower Defense - Improved</title>
  <style>
    body { margin: 0; padding: 0; font-family: 'Courier New', monospace; background-color: #222; color: #fff; }
    #game-container { position: relative; width: 800px; height: 500px; margin: 20px auto; overflow: hidden; box-shadow: 0 0 20px rgba(0, 0, 0, 0.7); }
    #game-board { position: relative; width: 100%; height: 100%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><rect width="100" height="100" fill="%233d4c2e" /><rect x="0" y="0" width="50" height="50" fill="%233a4929" opacity="0.4" /><rect x="50" y="50" width="50" height="50" fill="%233a4929" opacity="0.4" /></svg>'); }
    
    /* Terrain elements */
    .terrain { position: absolute; pointer-events: none; }
    .tree { width: 30px; height: 30px; font-size: 24px; text-align: center; }
    .rock { width: 20px; height: 20px; background-color: #777; border-radius: 5px; opacity: 0.8; }
    
    /* Strategic terrain types */
    .terrain.hill { 
      background: radial-gradient(circle, rgba(139, 125, 57, 0.3) 0%, rgba(139, 125, 57, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
    }
    .terrain.forest { 
      background: radial-gradient(circle, rgba(58, 73, 41, 0.4) 0%, rgba(58, 73, 41, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
    }
    .terrain.resource { 
      background: radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.1) 70%, transparent 100%);
      border-radius: 50%;
      cursor: pointer;
      animation: resourcePulse 2s infinite;
    }
    @keyframes resourcePulse {
      0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0.1); }
      100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
    }
    .terrain.decoration {
      cursor: default;
    }
    
    /* Terrain bonus indicators */
    .terrain-bonus {
      position: absolute;
      bottom: -5px;
      right: -5px;
      background-color: rgba(255, 204, 0, 0.8);
      color: #000;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      font-weight: bold;
      display: none;
    }
    
    .terrain:hover .terrain-bonus {
      display: block;
    }
    
    /* Improved path styling */
    .path { position: absolute; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="60" height="60"><rect width="60" height="60" fill="%238B4513" opacity="0.6" /><line x1="0" y1="20" x2="60" y2="20" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /><line x1="0" y1="40" x2="60" y2="40" stroke="%23a58d68" stroke-width="2" stroke-dasharray="5,5" /></svg>'); pointer-events: none; }
    
    /* Keep all other styles from original game */
    #info-panel { width: 800px; margin: 0 auto; display: flex; justify-content: space-between; padding: 10px; background-color: #3a3a3a; border: 3px solid #8b7d39; border-top: none; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
    #tower-selection { display: flex; gap: 10px; }
    .tower-option { width: 60px; height: 60px; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; border: 2px solid #777; border-radius: 5px; background-color: #444; transition: all 0.2s; }
    .tower-option:hover { background-color: #555; transform: translateY(-3px); }
    .tower-option.selected { border-color: #ffcc00; box-shadow: 0 0 10px #ffcc00; }
    .tower-icon { font-size: 24px; margin-bottom: 5px; }
    .tower-cost { font-size: 12px; font-weight: bold; color: #ffcc00; }
    .tower { 
      position: absolute; 
      width: 40px; 
      height: 40px; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      cursor: pointer; 
      z-index: 10; 
      font-size: 20px; 
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
      transition: transform 0.1s ease-out;
      overflow: visible;
    }
    .tower:hover { box-shadow: 0 0 8px 3px #ffcc00; }
    
    /* Tower turret (for rotation animations) */
    .tower-turret {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s ease-out;
      transform-origin: center center;
    }
    
    /* Tower barrel (extends from turret) */
    .tower-barrel {
      position: absolute;
      background-color: #333;
      border-radius: 2px;
      transform-origin: left center;
      transition: transform 0.1s ease-out;
      z-index: -1;
    }
    
    /* Different barrel styles for each tower type */
    .tower.mg .tower-barrel {
      width: 25px;
      height: 3px;
      right: -15px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #666;
    }
    
    .tower.artillery .tower-barrel {
      width: 30px;
      height: 6px;
      right: -20px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #4a7b49;
    }
    
    .tower.aa .tower-barrel {
      width: 20px;
      height: 4px;
      right: -12px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #3a6da3;
    }
    
    .tower.sniper .tower-barrel {
      width: 35px;
      height: 2px;
      right: -22px;
      top: 50%;
      transform: translateY(-50%);
      background-color: #8a4f3b;
    }
    
    /* Recoil animation */
    @keyframes recoilAnimation {
      0% { transform: scale(1); }
      20% { transform: scale(0.95) translateX(-2px); }
      100% { transform: scale(1) translateX(0); }
    }
    
    @keyframes barrelRecoil {
      0% { transform: translateY(-50%) scaleX(1); }
      30% { transform: translateY(-50%) scaleX(0.8); }
      100% { transform: translateY(-50%) scaleX(1); }
    }
    
    /* Firing animation classes */
    .tower.firing {
      animation: recoilAnimation 0.2s ease-out;
    }
    
    .tower.firing .tower-barrel {
      animation: barrelRecoil 0.2s ease-out;
    }
    
    /* Rotating animation for radar */
    .tower.radar .tower-turret {
      animation: radarRotate 4s linear infinite;
    }
    
    @keyframes radarRotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Idle animation for active towers */
    .tower.active {
      animation: towerIdle 3s ease-in-out infinite;
    }
    
    @keyframes towerIdle {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Dynamic Lighting Effects */
    .light-effect {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      z-index: 12;
      mix-blend-mode: screen;
    }
    
    /* Explosion lighting */
    .light-effect.explosion-light {
      background: radial-gradient(circle, 
        rgba(255, 165, 0, 0.8) 0%, 
        rgba(255, 69, 0, 0.6) 30%, 
        rgba(255, 140, 0, 0.3) 60%, 
        transparent 100%);
      animation: explosionLight 0.8s ease-out forwards;
    }
    
    @keyframes explosionLight {
      0% { 
        transform: scale(0.2); 
        opacity: 1; 
      }
      30% { 
        transform: scale(1.5); 
        opacity: 0.9; 
      }
      100% { 
        transform: scale(3); 
        opacity: 0; 
      }
    }
    
    /* Muzzle flash lighting */
    .light-effect.muzzle-light {
      background: radial-gradient(circle, 
        rgba(255, 255, 100, 0.7) 0%, 
        rgba(255, 200, 50, 0.4) 50%, 
        transparent 100%);
      animation: muzzleLight 0.15s ease-out forwards;
    }
    
    @keyframes muzzleLight {
      0% { 
        transform: scale(0.5); 
        opacity: 1; 
      }
      100% { 
        transform: scale(2); 
        opacity: 0; 
      }
    }
    
    /* Artillery shell light trail */
    .light-effect.shell-light {
      background: radial-gradient(circle, 
        rgba(255, 140, 0, 0.6) 0%, 
        rgba(255, 69, 0, 0.3) 50%, 
        transparent 100%);
      animation: shellLight 0.4s ease-out forwards;
    }
    
    @keyframes shellLight {
      0% { 
        transform: scale(0.8); 
        opacity: 0.8; 
      }
      100% { 
        transform: scale(1.5); 
        opacity: 0; 
      }
    }
    
    /* Ambient lighting for active towers */
    .tower.active::after {
      content: '';
      position: absolute;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, 
        rgba(255, 215, 0, 0.1) 0%, 
        rgba(255, 215, 0, 0.05) 50%, 
        transparent 100%);
      border-radius: 50%;
      top: -10px;
      left: -10px;
      pointer-events: none;
      z-index: -1;
      animation: ambientGlow 2s ease-in-out infinite;
    }
    
    @keyframes ambientGlow {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.1); }
    }
    
    /* Environmental lighting effects */
    .light-effect.resource-glow {
      background: radial-gradient(circle, 
        rgba(255, 215, 0, 0.2) 0%, 
        rgba(255, 215, 0, 0.1) 50%, 
        transparent 100%);
      animation: resourceGlow 3s ease-in-out infinite;
    }
    
    @keyframes resourceGlow {
      0%, 100% { opacity: 0.4; transform: scale(0.8); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    /* Screen overlay for dramatic lighting moments */
    .screen-flash {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      pointer-events: none;
      z-index: 20;
      animation: screenFlash 0.1s ease-out forwards;
    }
    
    @keyframes screenFlash {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    /* Weather System */
    .weather-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 18;
    }
    
    /* Rain Effect */
    .rain-drop {
      position: absolute;
      width: 2px;
      height: 15px;
      background: linear-gradient(to bottom, rgba(173, 216, 230, 0.8), rgba(173, 216, 230, 0.2));
      border-radius: 1px;
      animation: rainFall linear infinite;
    }
    
    @keyframes rainFall {
      to {
        transform: translateY(500px);
        opacity: 0;
      }
    }
    
    /* Fog Effect */
    .fog-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 120%;
      height: 120%;
      background: radial-gradient(ellipse at center, 
        rgba(220, 220, 220, 0.3) 0%, 
        rgba(200, 200, 200, 0.6) 30%, 
        rgba(180, 180, 180, 0.4) 70%, 
        transparent 100%);
      animation: fogDrift 20s ease-in-out infinite;
    }
    
    @keyframes fogDrift {
      0%, 100% { 
        transform: translateX(-10%) translateY(-10%); 
        opacity: 0.6; 
      }
      50% { 
        transform: translateX(10%) translateY(10%); 
        opacity: 0.8; 
      }
    }
    
    /* Snow Effect */
    .snow-flake {
      position: absolute;
      width: 4px;
      height: 4px;
      background: white;
      border-radius: 50%;
      opacity: 0.8;
      animation: snowFall linear infinite;
    }
    
    @keyframes snowFall {
      to {
        transform: translateY(500px) translateX(50px);
        opacity: 0;
      }
    }
    
    /* Weather visibility effects */
    .weather-reduced-visibility {
      filter: blur(1px) contrast(0.8);
    }
    
    .weather-heavy-reduced-visibility {
      filter: blur(2px) contrast(0.6) brightness(0.8);
    }
    
    /* Weather UI indicator */
    .weather-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      display: none;
      z-index: 25;
    }
    /* Realistic Tower Designs */
    .tower { position: relative; overflow: visible; }
    
    /* MG42 Machine Gun Nest */
    .tower.mg { 
      background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
      border: 2px solid #6e6e6e;
      border-radius: 3px;
    }
    .tower.mg::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 20px;
      height: 3px;
      background: #2c2c2c;
      border-radius: 2px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .tower.mg::after {
      content: '';
      position: absolute;
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: #4a4a4a;
      border-radius: 2px;
      border: 1px solid #6e6e6e;
    }
    
    /* 88mm Flak Gun */
    .tower.artillery { 
      background: radial-gradient(circle, #4a7b49, #2d572c);
      border: 2px solid #4a7b49;
      border-radius: 50%;
    }
    .tower.artillery::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25px;
      height: 4px;
      background: linear-gradient(90deg, #2c2c2c, #4a4a4a);
      border-radius: 2px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .tower.artillery::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 12px;
      height: 12px;
      background: #3a3a3a;
      border: 2px solid #5a5a5a;
      border-radius: 50%;
    }
    
    /* Bofors 40mm AA Gun */
    .tower.aa { 
      background: linear-gradient(145deg, #3a6da3, #1a3e5c);
      border: 2px solid #3a6da3;
      border-radius: 8px;
    }
    .tower.aa::before {
      content: '';
      position: absolute;
      top: 6px;
      left: 8px;
      width: 14px;
      height: 2px;
      background: #2c2c2c;
      border-radius: 1px;
      box-shadow: 0 4px 0 #2c2c2c;
    }
    .tower.aa::after {
      content: '';
      position: absolute;
      top: 4px;
      left: 6px;
      width: 6px;
      height: 6px;
      background: #4a4a4a;
      border: 1px solid #6a6a6a;
      border-radius: 3px;
    }
    
    /* Sniper Team */
    .tower.sniper { 
      background: linear-gradient(45deg, #4a3a2a, #5c2b1a, #3a2a1a);
      border: 2px solid #8a4f3b;
      border-radius: 4px;
    }
    .tower.sniper::before {
      content: '';
      position: absolute;
      top: 8px;
      left: 8px;
      width: 15px;
      height: 2px;
      background: #2c2c2c;
      border-radius: 1px;
      transform: rotate(45deg);
    }
    .tower.sniper::after {
      content: '‚óè';
      position: absolute;
      top: 5px;
      right: 5px;
      color: #ffaa00;
      font-size: 8px;
      text-shadow: 0 0 3px #ffaa00;
    }
    
    /* Combat Engineers */
    .tower.engineer { 
      background: linear-gradient(135deg, #d2691e, #8b4513);
      border: 2px solid #d2691e;
      border-radius: 2px;
    }
    .tower.engineer::before {
      content: '‚öí';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: #2c2c2c;
    }
    
    /* 81mm Mortar Team */
    .tower.mortar { 
      background: radial-gradient(circle, #6a5acd, #483d8b);
      border: 2px solid #6a5acd;
      border-radius: 50%;
    }
    .tower.mortar::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 3px;
      height: 15px;
      background: #2c2c2c;
      border-radius: 2px;
    }
    .tower.mortar::after {
      content: '';
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      width: 6px;
      height: 6px;
      background: #4a4a4a;
      border: 1px solid #6a6a6a;
      border-radius: 50%;
    }
    
    /* Radar Station */
    .tower.radar { 
      background: linear-gradient(145deg, #9370db, #4b0082);
      border: 2px solid #9370db;
      border-radius: 4px;
    }
    .tower.radar::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 18px;
      height: 18px;
      background: transparent;
      border: 2px solid #2c2c2c;
      border-radius: 50%;
      animation: radarSpin 3s linear infinite;
    }
    .tower.radar::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 2px;
      height: 8px;
      background: #ffaa00;
      border-radius: 1px;
      animation: radarSweep 3s linear infinite;
      transform-origin: bottom center;
    }
    
    @keyframes radarSpin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    /* Command Bunker */
    .tower.command { 
      background: linear-gradient(135deg, #9acd32, #556b2f);
      border: 2px solid #9acd32;
      border-radius: 3px;
    }
    .tower.command::before {
      content: '';
      position: absolute;
      top: 4px;
      left: 4px;
      right: 4px;
      height: 8px;
      background: #3a3a3a;
      border: 1px solid #5a5a5a;
      border-radius: 2px;
    }
    .tower.command::after {
      content: '';
      position: absolute;
      top: 6px;
      right: 6px;
      width: 4px;
      height: 4px;
      background: #ffaa00;
      border-radius: 50%;
      animation: commandBlink 2s infinite;
    }
    
    @keyframes commandBlink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }
    .tower-range { position: absolute; border-radius: 50%; background-color: rgba(255, 240, 130, 0.15); border: 1px dashed rgba(255, 204, 0, 0.3); pointer-events: none; z-index: 5; display: none; }
    .bullet { position: absolute; width: 6px; height: 6px; border-radius: 50%; z-index: 8; }
    .bullet.mg { background-color: #ffcc00; }
    .bullet.artillery { background-color: #ff6600; width: 8px; height: 8px; }
    .bullet.aa { background-color: #00ccff; }
    .bullet.sniper { background-color: #ff0000; width: 4px; height: 10px; }
    .bullet.mortar { background-color: #ffa500; width: 6px; height: 6px; border-radius: 30%; }
    .explosion { position: absolute; width: 40px; height: 40px; border-radius: 50%; background: radial-gradient(circle, rgba(255,102,0,0.8) 0%, rgba(255,153,0,0.6) 40%, rgba(255,204,0,0.2) 70%, rgba(255,204,0,0) 100%); z-index: 8; transform: translate(-50%, -50%); animation: explode 0.5s forwards; }
    @keyframes explode { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }
    .enemy { position: absolute; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 16px; z-index: 9; border-radius: 3px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); }
    .enemy.infantry { background-color: #8b0000; border: 1px solid #ff0000; }
    .enemy.tank { background-color: #b22222; width: 35px; height: 35px; border: 1px solid #ff3333; }
    .enemy.heavytank { background-color: #8b4500; width: 40px; height: 40px; border: 1px solid #ff7700; }
    .enemy.aircraft { background-color: #4b0082; border: 1px solid #9370db; }
    .enemy.elite { animation: pulse 1.5s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    .health-bar { position: absolute; width: 30px; height: 4px; background-color: #333; top: -8px; left: 0; border-radius: 2px; overflow: hidden; }
    .health-fill { height: 100%; background-color: #32cd32; width: 100%; transition: width 0.2s; }
    #start-button { padding: 8px 15px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
    #start-button:hover { background-color: #3e8e41; }
    #start-button:disabled { background-color: #cccccc; cursor: not-allowed; }
    #wave-info, #resources, #lives, #score-display { font-size: 16px; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.3); border-radius: 5px; margin-right: 10px; }
    #wave-info { color: #ffcc00; }
    #resources { color: #32cd32; }
    #lives { color: #ff6666; }
    #score-display { color: #66ccff; }
    #game-over, #level-complete { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); padding: 30px; border-radius: 10px; text-align: center; display: none; z-index: 100; border: 3px solid #8b7d39; box-shadow: 0 0 30px rgba(0, 0, 0, 0.8); width: 300px; }
    .game-over-title { color: #ff6666; margin-top: 0; font-size: 28px; }
    .victory-title { color: #32cd32; margin-top: 0; font-size: 28px; }
    .final-score { font-size: 20px; margin: 15px 0; color: #ffcc00; }
    button.restart { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 15px; cursor: pointer; font-size: 16px; }
    button.restart:hover { background-color: #3e8e41; }
    #instructions { width: 800px; margin: 10px auto; background-color: #3a3a3a; padding: 15px; border: 3px solid #8b7d39; border-radius: 5px; margin-bottom: 20px; }
    .difficulty-selection { display: flex; gap: 10px; margin-top: 10px; }
    .difficulty-btn { padding: 8px 15px; background-color: #555; border: none; color: white; border-radius: 5px; cursor: pointer; flex: 1; }
    .difficulty-btn:hover { background-color: #666; }
    .difficulty-btn.selected { background-color: #4CAF50; font-weight: bold; }
    .upgrade-panel { display: none; position: absolute; background-color: rgba(0, 0, 0, 0.8); border: 2px solid #ffcc00; border-radius: 5px; padding: 10px; z-index: 20; width: 150px; }
    .upgrade-option { margin-bottom: 8px; cursor: pointer; padding: 5px; background-color: #444; border-radius: 3px; }
    .upgrade-option:hover { background-color: #555; }
    .upgrade-option.disabled { opacity: 0.5; cursor: not-allowed; }
    .close-panel { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; font-size: 14px; }
    .ammo-bar { position: absolute; bottom: -8px; left: 0; width: 30px; height: 3px; background-color: #333; border-radius: 1px; overflow: hidden; }
    .ammo-fill { height: 100%; background-color: #ffaa00; width: 100%; }
    
    /* Special structures and effects */
    .wall { position: absolute; width: 20px; height: 20px; background-color: #8b4513; border: 1px solid #654321; z-index: 8; }
    .mine { position: absolute; width: 15px; height: 15px; background-color: #696969; border: 1px solid #2f4f4f; border-radius: 50%; z-index: 8; cursor: pointer; }
    .mine:hover { background-color: #ff4500; }
    .supply-convoy { position: absolute; width: 25px; height: 25px; background-color: #4CAF50; border: 2px solid #2E7D32; z-index: 9; font-size: 16px; display: flex; align-items: center; justify-content: center; }
    
    /* Radar detection effects */
    .radar-sweep { position: absolute; border-radius: 50%; border: 2px solid rgba(75, 0, 130, 0.6); animation: radarSweep 3s infinite; pointer-events: none; z-index: 6; }
    @keyframes radarSweep { 0% { transform: scale(0.1); opacity: 1; } 100% { transform: scale(1); opacity: 0; } }
    
    /* Command post aura */
    .command-aura { position: absolute; border-radius: 50%; background-color: rgba(154, 205, 50, 0.1); border: 1px dashed rgba(154, 205, 50, 0.3); pointer-events: none; z-index: 5; }
    
    /* Special action buttons */
    .action-buttons { position: absolute; display: none; z-index: 25; }
    .action-btn { padding: 4px 8px; margin: 2px; background-color: #444; color: white; border: 1px solid #666; border-radius: 3px; font-size: 12px; cursor: pointer; }
    .action-btn:hover { background-color: #555; }
    .action-btn.disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Particle System */
    .particle { 
      position: absolute; 
      pointer-events: none; 
      z-index: 15; 
      border-radius: 50%; 
    }
    
    /* Explosion particles */
    .particle.explosion { 
      background: radial-gradient(circle, #ff6600 0%, #ff9900 50%, #ffcc00 100%);
      animation: explodeParticle 0.8s ease-out forwards;
    }
    
    @keyframes explodeParticle {
      0% { 
        transform: scale(1) rotate(0deg); 
        opacity: 1; 
      }
      100% { 
        transform: scale(0.1) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    /* Muzzle flash particles */
    .particle.muzzle { 
      background: radial-gradient(circle, #ffff00 0%, #ff6600 50%, transparent 100%);
      animation: muzzleFlash 0.2s ease-out forwards;
    }
    
    @keyframes muzzleFlash {
      0% { 
        transform: scale(0.5); 
        opacity: 1; 
      }
      100% { 
        transform: scale(2); 
        opacity: 0; 
      }
    }
    
    /* Smoke particles */
    .particle.smoke { 
      background: radial-gradient(circle, rgba(80, 80, 80, 0.8) 0%, rgba(120, 120, 120, 0.4) 50%, transparent 100%);
      animation: smokeRise 2s ease-out forwards;
    }
    
    @keyframes smokeRise {
      0% { 
        transform: scale(0.5) translateY(0); 
        opacity: 0.8; 
      }
      100% { 
        transform: scale(2) translateY(-50px); 
        opacity: 0; 
      }
    }
    
    /* Bullet trail particles */
    .particle.trail { 
      background: linear-gradient(90deg, #ffcc00 0%, transparent 100%);
      border-radius: 50%;
      animation: trailFade 0.3s ease-out forwards;
    }
    
    @keyframes trailFade {
      0% { 
        opacity: 0.8; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.2); 
      }
    }
    
    /* Spark particles */
    .particle.spark { 
      background: #ffff00;
      animation: sparkFly 0.5s ease-out forwards;
    }
    
    @keyframes sparkFly {
      0% { 
        opacity: 1; 
        transform: scale(1); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.1); 
      }
    }
    
    /* Artillery shell particles */
    .particle.shell { 
      background: #8B4513;
      border-radius: 20%;
      animation: shellFly 0.4s ease-out forwards;
    }
    
    @keyframes shellFly {
      0% { 
        opacity: 1; 
        transform: scale(1) rotate(0deg); 
      }
      100% { 
        opacity: 0; 
        transform: scale(0.3) rotate(180deg); 
      }
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2 style="margin-top: 0;">WWII Tower Defense - Procedural Maps</h2>
    <p>Select a tower, place it on strategic terrain, and defend against waves of enemies!</p>
    <p><strong>Combat Towers:</strong> MG42 (üî´) - rapid fire vs infantry, 88mm Flak (üí•) - dual-purpose AT/AA, Bofors AA (üéØ) - anti-aircraft, Sniper Team (üéØ) - precision anti-personnel, Mortar (üéÜ) - indirect fire support</p>
    <p><strong>Support Towers:</strong> Engineers (‚öíÔ∏è) - build fortifications, Radar (üì°) - early warning system, Command Bunker (üèóÔ∏è) - coordinates all defenses</p>
    <p><strong>Strategic Elements:</strong> Hills (üèîÔ∏è) +25% range, Forests (üå≤) concealment, Resource nodes (üí∞) passive income, Supply convoys (üöõ) bonus resources</p>
    <div class="difficulty-selection">
      <button class="difficulty-btn selected" data-difficulty="normal">Normal</button>
      <button class="difficulty-btn" data-difficulty="hard">Hard</button>
      <button class="difficulty-btn" data-difficulty="veteran">Veteran</button>
      <button id="new-map-btn" style="padding: 8px 15px; background-color: #ff6600; border: none; color: white; border-radius: 5px; cursor: pointer; margin-left: 10px;" onclick="generateNewMap()">New Map</button>
    </div>
  </div>
  
  <div id="game-container">
    <div id="game-board">
      <!-- Paths will be created dynamically -->
      <div class="weather-overlay" id="weather-overlay"></div>
      <div class="weather-indicator" id="weather-indicator">Clear</div>
    </div>
    <div id="game-over">
      <h2 class="game-over-title">Game Over!</h2>
      <p>Your base was overrun!</p>
      <div class="final-score">Final Score: <span id="final-score">0</span></div>
      <button class="restart" onclick="restartGame()">Try Again</button>
    </div>
    <div id="level-complete">
      <h2 class="victory-title">Victory!</h2>
      <p>You successfully defended your position!</p>
      <div class="final-score">Final Score: <span id="victory-score">0</span></div>
      <button class="restart" onclick="restartGame()">Play Again</button>
    </div>
  </div>
  
  <div id="info-panel">
    <div style="display: flex;">
      <div id="wave-info">Wave: 0/12</div>
      <div id="resources">Resources: 150</div>
      <div id="lives">Base Health: 20/20</div>
      <div id="score-display">Score: 0</div>
    </div>
    <div id="tower-selection">
      <div class="tower-option" data-type="mg" onclick="selectTower('mg')">
        <div class="tower-icon">üë®‚Äçü¶Ø</div>
        <div class="tower-cost">$25</div>
      </div>
      <div class="tower-option" data-type="artillery" onclick="selectTower('artillery')">
        <div class="tower-icon">üí£</div>
        <div class="tower-cost">$50</div>
      </div>
      <div class="tower-option" data-type="aa" onclick="selectTower('aa')">
        <div class="tower-icon">‚ö°</div>
        <div class="tower-cost">$40</div>
      </div>
      <div class="tower-option" data-type="sniper" onclick="selectTower('sniper')">
        <div class="tower-icon">üî≠</div>
        <div class="tower-cost">$60</div>
      </div>
      <div class="tower-option" data-type="engineer" onclick="selectTower('engineer')">
        <div class="tower-icon">üîß</div>
        <div class="tower-cost">$45</div>
      </div>
      <div class="tower-option" data-type="radar" onclick="selectTower('radar')">
        <div class="tower-icon">üì°</div>
        <div class="tower-cost">$35</div>
      </div>
      <div class="tower-option" data-type="mortar" onclick="selectTower('mortar')">
        <div class="tower-icon">üéÜ</div>
        <div class="tower-cost">$50</div>
      </div>
      <div class="tower-option" data-type="command" onclick="selectTower('command')">
        <div class="tower-icon">üèóÔ∏è</div>
        <div class="tower-cost">$100</div>
      </div>
    </div>
    <button id="start-button" onclick="startWave()">Start Wave 1</button>
  </div>

  <div class="upgrade-panel" id="upgrade-panel">
    <div class="close-panel" onclick="closeUpgradePanel()">‚úï</div>
    <div class="upgrade-option" id="upgrade-damage" onclick="upgradeTower('damage')">Damage +25% ($30)</div>
    <div class="upgrade-option" id="upgrade-range" onclick="upgradeTower('range')">Range +15% ($25)</div>
    <div class="upgrade-option" id="upgrade-rate" onclick="upgradeTower('rate')">Fire Rate +20% ($35)</div>
  </div>

  <script>
    // Game state
    const gameState = {
      resources: 150, lives: 20, currentWave: 0, maxWaves: 12, waveInProgress: false,
      gameOver: false, victory: false, score: 0, selectedTowerType: null, selectedTower: null,
      towers: [], enemies: [], bullets: [], animationFrameId: null, difficulty: 'normal',
      lastFrameTime: 0, terrainElements: [], frameCounter: 0, enemySpeedMultiplier: 0.025,
      walls: [], mines: [], radarCoverage: false, nextWavePreview: null, supplyConvoys: [],
      lastConvoyTime: 0, particles: [], weather: { type: 'clear', intensity: 0, lastChange: 0 },
      coverSpots: [], enemyGroups: [], lastAIUpdate: 0,
      destructibleTerrain: [], craters: [], modifiedPaths: [],
      supplyTrucks: [], ammoDepots: [], lastSupplySpawn: 0,
      performanceMetrics: {
        enemiesKilled: 0, wavesCompleted: 0, accuracy: 100, efficiency: 100
      }
    };

    // Particle System
    class ParticleSystem {
      static createExplosionParticles(x, y, intensity = 8) {
        // Main explosion particles
        for (let i = 0; i < intensity; i++) {
          const angle = (Math.PI * 2 * i) / intensity;
          const speed = 50 + Math.random() * 30;
          const size = 6 + Math.random() * 8;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            type: 'explosion',
            life: 0.8
          });
        }
        
        // Smoke particles
        for (let i = 0; i < 4; i++) {
          this.createParticle({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 20,
            vy: -20 - Math.random() * 10,
            size: 15 + Math.random() * 10,
            type: 'smoke',
            life: 2
          });
        }
        
        // Sparks
        for (let i = 0; i < 6; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 40 + Math.random() * 40;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: 2 + Math.random() * 3,
            type: 'spark',
            life: 0.5
          });
        }
      }
      
      static createMuzzleFlash(x, y, angle = 0) {
        // Main muzzle flash
        this.createParticle({
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          size: 15 + Math.random() * 10,
          type: 'muzzle',
          life: 0.2,
          rotation: angle
        });
        
        // Sparks from muzzle
        for (let i = 0; i < 3; i++) {
          const sparkAngle = angle + (Math.random() - 0.5) * 0.5;
          const speed = 30 + Math.random() * 20;
          
          this.createParticle({
            x: x,
            y: y,
            vx: Math.cos(sparkAngle) * speed,
            vy: Math.sin(sparkAngle) * speed,
            size: 1 + Math.random() * 2,
            type: 'spark',
            life: 0.3
          });
        }
      }
      
      static createBulletTrail(x, y, targetX, targetY, bulletType = 'mg') {
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        
        // Create trail particles along bullet path
        const trailLength = Math.min(distance, 60);
        const numTrails = Math.floor(trailLength / 10);
        
        for (let i = 0; i < numTrails; i++) {
          const progress = i / numTrails;
          const trailX = x + dx * progress;
          const trailY = y + dy * progress;
          
          this.createParticle({
            x: trailX,
            y: trailY,
            vx: 0,
            vy: 0,
            size: bulletType === 'artillery' ? 4 : 2,
            type: 'trail',
            life: 0.3,
            rotation: angle,
            delay: i * 0.02 // Stagger the trail
          });
        }
      }
      
      static createArtilleryShell(x, y, targetX, targetY) {
        // Create shell particle that follows arc
        const dx = targetX - x;
        const dy = targetY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        this.createParticle({
          x: x,
          y: y,
          vx: dx * 0.01,
          vy: dy * 0.01 - distance * 0.001, // Arc trajectory
          size: 6,
          type: 'shell',
          life: 0.4,
          gravity: 0.5
        });
      }
      
      static createParticle(config) {
        const particle = document.createElement('div');
        particle.className = `particle ${config.type}`;
        particle.style.width = `${config.size}px`;
        particle.style.height = `${config.size}px`;
        particle.style.left = `${config.x - config.size/2}px`;
        particle.style.top = `${config.y - config.size/2}px`;
        
        if (config.rotation !== undefined) {
          particle.style.transform = `rotate(${config.rotation}rad)`;
        }
        
        if (config.delay) {
          particle.style.animationDelay = `${config.delay}s`;
        }
        
        gameBoard.appendChild(particle);
        
        const particleObj = {
          element: particle,
          x: config.x,
          y: config.y,
          vx: config.vx || 0,
          vy: config.vy || 0,
          size: config.size,
          life: config.life,
          maxLife: config.life,
          type: config.type,
          gravity: config.gravity || 0
        };
        
        gameState.particles.push(particleObj);
        
        // Remove particle after animation
        setTimeout(() => {
          this.removeParticle(particleObj);
        }, config.life * 1000);
      }
      
      static updateParticles(deltaTime) {
        const particlesToRemove = [];
        
        gameState.particles.forEach(particle => {
          // Update physics for certain particle types
          if (particle.type === 'explosion' || particle.type === 'spark' || particle.type === 'shell') {
            particle.x += particle.vx * deltaTime * 0.01;
            particle.y += particle.vy * deltaTime * 0.01;
            
            if (particle.gravity) {
              particle.vy += particle.gravity * deltaTime * 0.1;
            }
            
            particle.element.style.left = `${particle.x - particle.size/2}px`;
            particle.element.style.top = `${particle.y - particle.size/2}px`;
          }
          
          // Update life
          particle.life -= deltaTime * 0.001;
          if (particle.life <= 0) {
            particlesToRemove.push(particle);
          }
        });
        
        particlesToRemove.forEach(particle => this.removeParticle(particle));
      }
      
      static removeParticle(particle) {
        if (particle.element && particle.element.parentNode) {
          particle.element.remove();
        }
        const index = gameState.particles.indexOf(particle);
        if (index !== -1) {
          gameState.particles.splice(index, 1);
        }
      }
      
      static clearAllParticles() {
        gameState.particles.forEach(particle => {
          if (particle.element && particle.element.parentNode) {
            particle.element.remove();
          }
        });
        gameState.particles = [];
      }
    }

    // Dynamic Lighting System
    class LightingSystem {
      static createExplosionLight(x, y, intensity = 1) {
        const light = document.createElement('div');
        light.className = 'light-effect explosion-light';
        const size = 80 * intensity;
        light.style.width = `${size}px`;
        light.style.height = `${size}px`;
        light.style.left = `${x - size/2}px`;
        light.style.top = `${y - size/2}px`;
        
        gameBoard.appendChild(light);
        
        // Add screen flash for large explosions
        if (intensity > 1.5) {
          this.createScreenFlash();
        }
        
        setTimeout(() => light.remove(), 800);
      }
      
      static createMuzzleLight(x, y, angle = 0) {
        const light = document.createElement('div');
        light.className = 'light-effect muzzle-light';
        light.style.width = '40px';
        light.style.height = '40px';
        light.style.left = `${x - 20}px`;
        light.style.top = `${y - 20}px`;
        
        gameBoard.appendChild(light);
        setTimeout(() => light.remove(), 150);
      }
      
      static createShellLight(x, y) {
        const light = document.createElement('div');
        light.className = 'light-effect shell-light';
        light.style.width = '30px';
        light.style.height = '30px';
        light.style.left = `${x - 15}px`;
        light.style.top = `${y - 15}px`;
        
        gameBoard.appendChild(light);
        setTimeout(() => light.remove(), 400);
      }
      
      static createScreenFlash() {
        const flash = document.createElement('div');
        flash.className = 'screen-flash';
        gameBoard.appendChild(flash);
        setTimeout(() => flash.remove(), 100);
      }
      
      static addResourceGlow(element, x, y) {
        const glow = document.createElement('div');
        glow.className = 'light-effect resource-glow';
        glow.style.width = '80px';
        glow.style.height = '80px';
        glow.style.left = `${x - 40}px`;
        glow.style.top = `${y - 40}px`;
        
        gameBoard.appendChild(glow);
        
        // Store reference to remove later
        element.lightGlow = glow;
      }
      
      static removeResourceGlow(element) {
        if (element.lightGlow && element.lightGlow.parentNode) {
          element.lightGlow.remove();
          element.lightGlow = null;
        }
      }
      
      static clearAllLights() {
        document.querySelectorAll('.light-effect').forEach(light => light.remove());
        document.querySelectorAll('.screen-flash').forEach(flash => flash.remove());
      }
    }

    // Weather System
    class WeatherSystem {
      static weatherTypes = ['clear', 'rain', 'fog', 'snow'];
      static weatherOverlay = null;
      static weatherIndicator = null;
      
      static init() {
        this.weatherOverlay = document.getElementById('weather-overlay');
        this.weatherIndicator = document.getElementById('weather-indicator');
      }
      
      static updateWeather(currentTime) {
        // Change weather every 30-60 seconds
        if (currentTime - gameState.weather.lastChange > 30000 + Math.random() * 30000) {
          this.changeWeather();
          gameState.weather.lastChange = currentTime;
        }
        
        // Update weather effects
        this.updateWeatherEffects();
      }
      
      static changeWeather() {
        // More likely to have clear weather, less chance of severe weather
        const weatherChances = [0.4, 0.25, 0.2, 0.15]; // clear, rain, fog, snow
        const random = Math.random();
        let cumulativeChance = 0;
        
        for (let i = 0; i < this.weatherTypes.length; i++) {
          cumulativeChance += weatherChances[i];
          if (random <= cumulativeChance) {
            gameState.weather.type = this.weatherTypes[i];
            break;
          }
        }
        
        // Set intensity (0.3 to 1.0)
        gameState.weather.intensity = 0.3 + Math.random() * 0.7;
        
        this.applyWeatherEffects();
        this.updateWeatherIndicator();
      }
      
      static applyWeatherEffects() {
        // Clear previous weather effects
        this.clearWeatherEffects();
        
        const weather = gameState.weather;
        
        switch (weather.type) {
          case 'rain':
            this.createRainEffect(weather.intensity);
            this.applyVisibilityReduction('light');
            break;
          case 'fog':
            this.createFogEffect(weather.intensity);
            this.applyVisibilityReduction('heavy');
            break;
          case 'snow':
            this.createSnowEffect(weather.intensity);
            this.applyVisibilityReduction('light');
            break;
          default:
            this.clearVisibilityEffects();
        }
      }
      
      static createRainEffect(intensity) {
        const numDrops = Math.floor(50 * intensity);
        
        for (let i = 0; i < numDrops; i++) {
          setTimeout(() => {
            if (gameState.weather.type === 'rain') {
              this.createRainDrop();
            }
          }, Math.random() * 1000);
        }
        
        // Continue creating rain drops while weather is active
        if (gameState.weather.type === 'rain') {
          setTimeout(() => {
            if (gameState.weather.type === 'rain') {
              this.createRainEffect(intensity);
            }
          }, 1000);
        }
      }
      
      static createRainDrop() {
        const drop = document.createElement('div');
        drop.className = 'rain-drop';
        drop.style.left = `${Math.random() * 100}%`;
        drop.style.top = '-20px';
        drop.style.animationDuration = `${0.5 + Math.random() * 0.5}s`;
        drop.style.animationDelay = `${Math.random() * 0.2}s`;
        
        this.weatherOverlay.appendChild(drop);
        
        setTimeout(() => {
          if (drop.parentNode) {
            drop.remove();
          }
        }, 1000);
      }
      
      static createFogEffect(intensity) {
        const fog = document.createElement('div');
        fog.className = 'fog-layer';
        fog.style.opacity = intensity * 0.8;
        this.weatherOverlay.appendChild(fog);
      }
      
      static createSnowEffect(intensity) {
        const numFlakes = Math.floor(30 * intensity);
        
        for (let i = 0; i < numFlakes; i++) {
          setTimeout(() => {
            if (gameState.weather.type === 'snow') {
              this.createSnowFlake();
            }
          }, Math.random() * 2000);
        }
        
        // Continue creating snowflakes
        if (gameState.weather.type === 'snow') {
          setTimeout(() => {
            if (gameState.weather.type === 'snow') {
              this.createSnowEffect(intensity);
            }
          }, 2000);
        }
      }
      
      static createSnowFlake() {
        const flake = document.createElement('div');
        flake.className = 'snow-flake';
        flake.style.left = `${Math.random() * 100}%`;
        flake.style.top = '-10px';
        flake.style.animationDuration = `${2 + Math.random() * 3}s`;
        flake.style.animationDelay = `${Math.random() * 1}s`;
        
        this.weatherOverlay.appendChild(flake);
        
        setTimeout(() => {
          if (flake.parentNode) {
            flake.remove();
          }
        }, 6000);
      }
      
      static applyVisibilityReduction(level) {
        const gameBoard = document.getElementById('game-board');
        
        if (level === 'light') {
          gameBoard.classList.add('weather-reduced-visibility');
        } else if (level === 'heavy') {
          gameBoard.classList.add('weather-heavy-reduced-visibility');
        }
        
        // Reduce tower range in bad weather
        gameState.towers.forEach(tower => {
          if (!tower.originalRange) {
            tower.originalRange = tower.range;
          }
          
          const reduction = level === 'heavy' ? 0.7 : 0.85;
          tower.range = tower.originalRange * reduction;
          
          // Update range indicator
          const rangeIndicator = tower.element.querySelector('.tower-range');
          if (rangeIndicator) {
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
        });
      }
      
      static clearVisibilityEffects() {
        const gameBoard = document.getElementById('game-board');
        gameBoard.classList.remove('weather-reduced-visibility', 'weather-heavy-reduced-visibility');
        
        // Restore original tower ranges
        gameState.towers.forEach(tower => {
          if (tower.originalRange) {
            tower.range = tower.originalRange;
            
            // Update range indicator
            const rangeIndicator = tower.element.querySelector('.tower-range');
            if (rangeIndicator) {
              rangeIndicator.style.width = `${tower.range * 2}px`;
              rangeIndicator.style.height = `${tower.range * 2}px`;
              rangeIndicator.style.left = `-${tower.range - 20}px`;
              rangeIndicator.style.top = `-${tower.range - 20}px`;
            }
          }
        });
      }
      
      static clearWeatherEffects() {
        if (this.weatherOverlay) {
          this.weatherOverlay.innerHTML = '';
        }
        this.clearVisibilityEffects();
      }
      
      static updateWeatherIndicator() {
        if (this.weatherIndicator) {
          const weather = gameState.weather;
          let text = weather.type.charAt(0).toUpperCase() + weather.type.slice(1);
          
          if (weather.type !== 'clear') {
            const intensityText = weather.intensity > 0.7 ? 'Heavy ' : weather.intensity > 0.4 ? 'Light ' : '';
            text = intensityText + text;
          }
          
          this.weatherIndicator.textContent = text;
          this.weatherIndicator.style.display = weather.type === 'clear' ? 'none' : 'block';
        }
      }
      
      static updateWeatherEffects() {
        // Update any dynamic weather effects here if needed
      }
    }

    // Advanced Enemy AI System
    class EnemyAI {
      static initializeCoverSystem() {
        // Generate cover spots around terrain features
        gameState.coverSpots = [];
        
        terrainFeatures.forEach(feature => {
          if (feature.type === 'forest' || feature.type === 'hill') {
            // Create cover spots around terrain features
            const numSpots = Math.floor(feature.radius / 20);
            for (let i = 0; i < numSpots; i++) {
              const angle = (Math.PI * 2 * i) / numSpots;
              const distance = feature.radius * 0.8;
              const coverSpot = {
                x: feature.x + Math.cos(angle) * distance,
                y: feature.y + Math.sin(angle) * distance,
                radius: 15,
                occupied: false,
                coverValue: feature.type === 'forest' ? 0.7 : 0.5, // Forest provides better cover
                terrainType: feature.type
              };
              gameState.coverSpots.push(coverSpot);
            }
          }
        });
      }
      
      static updateEnemyAI(deltaTime) {
        // Group enemies for coordinated behavior
        this.updateEnemyGroups();
        
        // Update individual enemy AI
        gameState.enemies.forEach(enemy => {
          this.updateEnemyBehavior(enemy, deltaTime);
        });
        
        // Update group tactics
        gameState.enemyGroups.forEach(group => {
          this.updateGroupTactics(group, deltaTime);
        });
      }
      
      static updateEnemyGroups() {
        gameState.enemyGroups = [];
        const processedEnemies = new Set();
        
        gameState.enemies.forEach(enemy => {
          if (processedEnemies.has(enemy.id)) return;
          
          // Find nearby enemies to form a group
          const group = {
            id: Math.random().toString(36).substr(2, 9),
            members: [enemy],
            leader: enemy,
            formation: 'line', // line, wedge, scattered
            objective: 'advance', // advance, regroup, assault, retreat
            targetTower: null,
            lastTacticChange: Date.now()
          };
          
          gameState.enemies.forEach(otherEnemy => {
            if (otherEnemy.id !== enemy.id && !processedEnemies.has(otherEnemy.id)) {
              const dx = enemy.x - otherEnemy.x;
              const dy = enemy.y - otherEnemy.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Group enemies within 80 units of each other
              if (distance <= 80 && group.members.length < 6) {
                group.members.push(otherEnemy);
                processedEnemies.add(otherEnemy.id);
                
                // The strongest enemy becomes the leader
                if (otherEnemy.maxHealth > group.leader.maxHealth) {
                  group.leader = otherEnemy;
                }
              }
            }
          });
          
          processedEnemies.add(enemy.id);
          if (group.members.length > 1) {
            gameState.enemyGroups.push(group);
          }
        });
      }
      
      static updateEnemyBehavior(enemy, deltaTime) {
        if (!enemy.aiState) {
          enemy.aiState = {
            behavior: 'advancing', // advancing, seeking_cover, in_cover, flanking, retreating
            target: null,
            coverSpot: null,
            lastDecision: Date.now(),
            threatLevel: 0,
            flankingPath: null,
            originalSpeed: enemy.speed
          };
        }
        
        const aiState = enemy.aiState;
        const currentTime = Date.now();
        
        // Update threat assessment
        this.assessThreat(enemy);
        
        // Make decisions every 500ms
        if (currentTime - aiState.lastDecision > 500) {
          this.makeDecision(enemy);
          aiState.lastDecision = currentTime;
        }
        
        // Execute current behavior
        this.executeBehavior(enemy, deltaTime);
      }
      
      static assessThreat(enemy) {
        const aiState = enemy.aiState;
        let threatLevel = 0;
        
        // Check nearby towers
        gameState.towers.forEach(tower => {
          const dx = enemy.x - tower.x;
          const dy = enemy.y - tower.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= tower.range) {
            // Higher threat for towers that can target this enemy type
            if (tower.targets.includes(enemy.type)) {
              const threat = (tower.range - distance) / tower.range;
              threatLevel += threat * (tower.damage / 3);
            }
          }
        });
        
        // Consider recent damage
        if (enemy.recentDamage && Date.now() - enemy.recentDamage < 2000) {
          threatLevel += 0.5;
        }
        
        aiState.threatLevel = Math.min(threatLevel, 2.0);
      }
      
      static makeDecision(enemy) {
        const aiState = enemy.aiState;
        const threatLevel = aiState.threatLevel;
        
        // Decision tree based on threat level and enemy type
        if (threatLevel > 1.5 && enemy.health < enemy.maxHealth * 0.4) {
          // High threat, low health - seek cover or retreat
          if (Math.random() < 0.7) {
            this.seekCover(enemy);
          } else {
            aiState.behavior = 'retreating';
          }
        } else if (threatLevel > 1.0 && enemy.type !== 'aircraft') {
          // Moderate threat - seek cover or try flanking
          if (Math.random() < 0.6) {
            this.seekCover(enemy);
          } else {
            this.attemptFlanking(enemy);
          }
        } else if (threatLevel > 0.5 && Math.random() < 0.3) {
          // Low threat but cautious - occasional cover seeking
          this.seekCover(enemy);
        } else {
          // Default - advance along path
          aiState.behavior = 'advancing';
          aiState.coverSpot = null;
        }
      }
      
      static seekCover(enemy) {
        const aiState = enemy.aiState;
        let bestCover = null;
        let bestScore = -1;
        
        gameState.coverSpots.forEach(spot => {
          if (spot.occupied) return;
          
          const dx = enemy.x - spot.x;
          const dy = enemy.y - spot.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Score based on cover value, distance, and tower threat reduction
          let score = spot.coverValue;
          score -= distance / 100; // Prefer closer cover
          
          // Check if cover actually reduces tower threat
          let threatReduction = 0;
          gameState.towers.forEach(tower => {
            const towerDx = spot.x - tower.x;
            const towerDy = spot.y - tower.y;
            const towerDistance = Math.sqrt(towerDx * towerDx + towerDy * towerDy);
            
            if (towerDistance <= tower.range && tower.targets.includes(enemy.type)) {
              threatReduction += spot.coverValue * 0.5;
            }
          });
          
          score += threatReduction;
          
          if (score > bestScore && distance <= 120) {
            bestScore = score;
            bestCover = spot;
          }
        });
        
        if (bestCover) {
          aiState.behavior = 'seeking_cover';
          aiState.coverSpot = bestCover;
          bestCover.occupied = true;
        }
      }
      
      static attemptFlanking(enemy) {
        const aiState = enemy.aiState;
        
        // Find the most threatening tower
        let primaryThreat = null;
        let maxThreat = 0;
        
        gameState.towers.forEach(tower => {
          const dx = enemy.x - tower.x;
          const dy = enemy.y - tower.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= tower.range && tower.targets.includes(enemy.type)) {
            const threat = tower.damage * (tower.range - distance) / tower.range;
            if (threat > maxThreat) {
              maxThreat = threat;
              primaryThreat = tower;
            }
          }
        });
        
        if (primaryThreat) {
          // Try to flank around the tower
          const towerX = primaryThreat.x;
          const towerY = primaryThreat.y;
          const flankDistance = primaryThreat.range * 1.2;
          
          // Choose flanking direction (left or right of tower)
          const angle = Math.atan2(enemy.y - towerY, enemy.x - towerX);
          const flankAngle = angle + (Math.random() < 0.5 ? Math.PI/2 : -Math.PI/2);
          
          aiState.behavior = 'flanking';
          aiState.flankingPath = {
            x: towerX + Math.cos(flankAngle) * flankDistance,
            y: towerY + Math.sin(flankAngle) * flankDistance,
            targetTower: primaryThreat
          };
        }
      }
      
      static executeBehavior(enemy, deltaTime) {
        const aiState = enemy.aiState;
        
        switch (aiState.behavior) {
          case 'seeking_cover':
            this.moveTowardsCover(enemy, deltaTime);
            break;
          case 'in_cover':
            this.stayInCover(enemy, deltaTime);
            break;
          case 'flanking':
            this.executeFlankingManeuver(enemy, deltaTime);
            break;
          case 'retreating':
            this.executeRetreat(enemy, deltaTime);
            break;
          default: // advancing
            this.resumeNormalMovement(enemy, deltaTime);
            break;
        }
      }
      
      static moveTowardsCover(enemy, deltaTime) {
        const aiState = enemy.aiState;
        const coverSpot = aiState.coverSpot;
        
        if (!coverSpot) {
          aiState.behavior = 'advancing';
          return;
        }
        
        const dx = coverSpot.x - enemy.x;
        const dy = coverSpot.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 10) {
          aiState.behavior = 'in_cover';
          aiState.coverTime = Date.now();
        } else {
          // Move towards cover at reduced speed
          const moveSpeed = aiState.originalSpeed * 0.8 * (deltaTime / 16);
          enemy.x += (dx / distance) * moveSpeed;
          enemy.y += (dy / distance) * moveSpeed;
          
          // Update visual position
          enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
          enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
        }
      }
      
      static stayInCover(enemy, deltaTime) {
        const aiState = enemy.aiState;
        
        // Stay in cover for 2-4 seconds
        const coverDuration = 2000 + Math.random() * 2000;
        if (Date.now() - aiState.coverTime > coverDuration || aiState.threatLevel < 0.3) {
          // Leave cover
          if (aiState.coverSpot) {
            aiState.coverSpot.occupied = false;
            aiState.coverSpot = null;
          }
          aiState.behavior = 'advancing';
        }
        
        // Slight movement while in cover
        enemy.x += (Math.random() - 0.5) * 2;
        enemy.y += (Math.random() - 0.5) * 2;
        enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
        enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
      }
      
      static executeFlankingManeuver(enemy, deltaTime) {
        const aiState = enemy.aiState;
        const flankPath = aiState.flankingPath;
        
        if (!flankPath) {
          aiState.behavior = 'advancing';
          return;
        }
        
        const dx = flankPath.x - enemy.x;
        const dy = flankPath.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 20) {
          // Flanking position reached, resume normal movement
          aiState.behavior = 'advancing';
          aiState.flankingPath = null;
        } else {
          // Move towards flanking position at increased speed
          const moveSpeed = aiState.originalSpeed * 1.2 * (deltaTime / 16);
          enemy.x += (dx / distance) * moveSpeed;
          enemy.y += (dy / distance) * moveSpeed;
          
          enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
          enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
        }
      }
      
      static executeRetreat(enemy, deltaTime) {
        const aiState = enemy.aiState;
        
        // Move backwards along the path
        if (enemy.pathIndex > 0) {
          enemy.pathIndex -= 0.5 * (deltaTime / 16);
          if (enemy.pathIndex < 0) enemy.pathIndex = 0;
          
          const currentPoint = path[Math.floor(enemy.pathIndex)];
          if (currentPoint) {
            enemy.x = currentPoint.x;
            enemy.y = currentPoint.y;
            enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
            enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
          }
        }
        
        // Stop retreating after some time or if health improves
        if (Date.now() - aiState.lastDecision > 3000 || enemy.health > enemy.maxHealth * 0.6) {
          aiState.behavior = 'advancing';
        }
      }
      
      static resumeNormalMovement(enemy, deltaTime) {
        // Resume normal path following with slight speed variation
        const speedMultiplier = 0.9 + Math.random() * 0.2; // 90-110% normal speed
        enemy.speed = enemy.aiState.originalSpeed * speedMultiplier;
      }
      
      static updateGroupTactics(group, deltaTime) {
        const currentTime = Date.now();
        
        // Change tactics every 5-10 seconds
        if (currentTime - group.lastTacticChange > 5000 + Math.random() * 5000) {
          this.chooseGroupTactic(group);
          group.lastTacticChange = currentTime;
        }
        
        // Execute group tactics
        this.executeGroupTactic(group, deltaTime);
      }
      
      static chooseGroupTactic(group) {
        const avgHealth = group.members.reduce((sum, enemy) => sum + enemy.health, 0) / group.members.length;
        const avgMaxHealth = group.members.reduce((sum, enemy) => sum + enemy.maxHealth, 0) / group.members.length;
        const healthRatio = avgHealth / avgMaxHealth;
        
        if (healthRatio < 0.4) {
          group.objective = 'regroup';
          group.formation = 'scattered';
        } else if (healthRatio > 0.8 && Math.random() < 0.3) {
          group.objective = 'assault';
          group.formation = 'wedge';
          // Target the weakest tower
          group.targetTower = this.findWeakestTower(group);
        } else {
          group.objective = 'advance';
          group.formation = Math.random() < 0.5 ? 'line' : 'scattered';
        }
      }
      
      static findWeakestTower(group) {
        let weakestTower = null;
        let minEffectiveness = Infinity;
        
        gameState.towers.forEach(tower => {
          const effectiveness = tower.damage * tower.fireRate * tower.ammo;
          if (effectiveness < minEffectiveness) {
            minEffectiveness = effectiveness;
            weakestTower = tower;
          }
        });
        
        return weakestTower;
      }
      
      static executeGroupTactic(group, deltaTime) {
        switch (group.objective) {
          case 'regroup':
            this.executeRegroup(group, deltaTime);
            break;
          case 'assault':
            this.executeAssault(group, deltaTime);
            break;
          default: // advance
            this.executeAdvance(group, deltaTime);
            break;
        }
      }
      
      static executeRegroup(group, deltaTime) {
        const leader = group.leader;
        
        group.members.forEach(enemy => {
          if (enemy === leader) return;
          
          const dx = leader.x - enemy.x;
          const dy = leader.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 40) {
            // Move towards leader
            const moveSpeed = enemy.aiState.originalSpeed * 0.6 * (deltaTime / 16);
            enemy.x += (dx / distance) * moveSpeed;
            enemy.y += (dy / distance) * moveSpeed;
            
            enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
            enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
          }
        });
      }
      
      static executeAssault(group, deltaTime) {
        if (!group.targetTower) return;
        
        const target = group.targetTower;
        
        group.members.forEach(enemy => {
          const dx = target.x - enemy.x;
          const dy = target.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 30) {
            // Move towards target tower aggressively
            const moveSpeed = enemy.aiState.originalSpeed * 1.3 * (deltaTime / 16);
            enemy.x += (dx / distance) * moveSpeed;
            enemy.y += (dy / distance) * moveSpeed;
            
            enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
            enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
          }
        });
      }
      
      static executeAdvance(group, deltaTime) {
        // Maintain formation while advancing
        if (group.formation === 'line') {
          this.maintainLineFormation(group, deltaTime);
        } else if (group.formation === 'wedge') {
          this.maintainWedgeFormation(group, deltaTime);
        }
        // Scattered formation doesn't need special coordination
      }
      
      static maintainLineFormation(group, deltaTime) {
        const leader = group.leader;
        const members = group.members.filter(m => m !== leader);
        
        members.forEach((enemy, index) => {
          const offset = (index - (members.length - 1) / 2) * 30;
          const targetX = leader.x + offset;
          const targetY = leader.y;
          
          const dx = targetX - enemy.x;
          const dy = targetY - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 15) {
            const moveSpeed = enemy.aiState.originalSpeed * 0.8 * (deltaTime / 16);
            enemy.x += (dx / distance) * moveSpeed;
            enemy.y += (dy / distance) * moveSpeed;
            
            enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
            enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
          }
        });
      }
      
      static maintainWedgeFormation(group, deltaTime) {
        const leader = group.leader;
        const members = group.members.filter(m => m !== leader);
        
        members.forEach((enemy, index) => {
          const side = index % 2 === 0 ? 1 : -1;
          const rank = Math.floor(index / 2) + 1;
          const targetX = leader.x + side * rank * 25;
          const targetY = leader.y + rank * 30;
          
          const dx = targetX - enemy.x;
          const dy = targetY - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance > 15) {
            const moveSpeed = enemy.aiState.originalSpeed * 0.8 * (deltaTime / 16);
            enemy.x += (dx / distance) * moveSpeed;
            enemy.y += (dy / distance) * moveSpeed;
            
            enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
            enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
          }
        });
      }
      
      static cleanupAI() {
        // Free up cover spots
        gameState.coverSpots.forEach(spot => {
          spot.occupied = false;
        });
        gameState.enemyGroups = [];
      }
    }

    // Destructible Terrain System
    class DestructibleTerrain {
      static initializeDestructibleElements() {
        gameState.destructibleTerrain = [];
        
        // Add destructible terrain around some features (but not forests/clouds)
        terrainFeatures.forEach(feature => {
          if (feature.type === 'hill' && Math.random() < 0.4) {
            // Create destructible terrain patches only around hills
            const numPatches = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < numPatches; i++) {
              const angle = Math.random() * Math.PI * 2;
              const distance = 30 + Math.random() * 40;
              
              const destructible = {
                id: Math.random().toString(36).substr(2, 9),
                x: feature.x + Math.cos(angle) * distance,
                y: feature.y + Math.sin(angle) * distance,
                radius: 25 + Math.random() * 15,
                health: 50 + Math.random() * 30,
                maxHealth: 50 + Math.random() * 30,
                type: 'rock_formation', // rock_formation, building_ruins, bunker
                element: null,
                destroyed: false
              };
              
              destructible.maxHealth = destructible.health;
              gameState.destructibleTerrain.push(destructible);
              this.createDestructibleElement(destructible);
            }
          }
        });
        
        // Add some standalone destructible elements
        for (let i = 0; i < 8; i++) {
          const destructible = {
            id: Math.random().toString(36).substr(2, 9),
            x: 100 + Math.random() * 600,
            y: 50 + Math.random() * 400,
            radius: 20 + Math.random() * 20,
            health: 30 + Math.random() * 40,
            maxHealth: 30 + Math.random() * 40,
            type: ['rock_formation', 'building_ruins', 'bunker'][Math.floor(Math.random() * 3)],
            element: null,
            destroyed: false
          };
          
          // Don't place on paths
          const onPath = path.some(point => {
            const dx = point.x - destructible.x;
            const dy = point.y - destructible.y;
            return Math.sqrt(dx * dx + dy * dy) < 40;
          });
          
          if (!onPath) {
            destructible.maxHealth = destructible.health;
            gameState.destructibleTerrain.push(destructible);
            this.createDestructibleElement(destructible);
          }
        }
      }
      
      static createDestructibleElement(destructible) {
        const element = document.createElement('div');
        element.className = 'destructible-terrain';
        element.style.position = 'absolute';
        element.style.width = `${destructible.radius * 2}px`;
        element.style.height = `${destructible.radius * 2}px`;
        element.style.left = `${destructible.x - destructible.radius}px`;
        element.style.top = `${destructible.y - destructible.radius}px`;
        element.style.borderRadius = '20%';
        element.style.cursor = 'crosshair';
        element.style.zIndex = '7';
        element.style.display = 'flex';
        element.style.alignItems = 'center';
        element.style.justifyContent = 'center';
        element.style.fontSize = '16px';
        element.style.transition = 'all 0.3s ease';
        
        // Style based on type
        switch (destructible.type) {
          case 'rock_formation':
            element.style.backgroundColor = 'rgba(120, 120, 120, 0.8)';
            element.style.border = '2px solid #888';
            element.textContent = 'ü™®';
            break;
          case 'building_ruins':
            element.style.backgroundColor = 'rgba(139, 69, 19, 0.8)';
            element.style.border = '2px solid #8B4513';
            element.textContent = 'üèöÔ∏è';
            break;
          case 'bunker':
            element.style.backgroundColor = 'rgba(85, 85, 85, 0.9)';
            element.style.border = '2px solid #555';
            element.textContent = 'üèõÔ∏è';
            break;
        }
        
        // Add health bar
        const healthBar = document.createElement('div');
        healthBar.className = 'terrain-health-bar';
        healthBar.style.position = 'absolute';
        healthBar.style.width = '100%';
        healthBar.style.height = '4px';
        healthBar.style.backgroundColor = '#333';
        healthBar.style.bottom = '-6px';
        healthBar.style.left = '0';
        healthBar.style.borderRadius = '2px';
        healthBar.style.overflow = 'hidden';
        
        const healthFill = document.createElement('div');
        healthFill.className = 'terrain-health-fill';
        healthFill.style.height = '100%';
        healthFill.style.backgroundColor = '#32cd32';
        healthFill.style.width = '100%';
        healthFill.style.transition = 'width 0.2s';
        healthBar.appendChild(healthFill);
        element.appendChild(healthBar);
        
        destructible.element = element;
        destructible.healthFill = healthFill;
        gameBoard.appendChild(element);
        
        // Add click handler for manual destruction (testing)
        element.addEventListener('click', (e) => {
          e.stopPropagation();
          this.damageDestructible(destructible, 20);
        });
      }
      
      static checkArtilleryImpact(x, y, damage, splashRadius) {
        const impactedTerrain = [];
        
        gameState.destructibleTerrain.forEach(terrain => {
          if (terrain.destroyed) return;
          
          const dx = terrain.x - x;
          const dy = terrain.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= splashRadius + terrain.radius) {
            // Calculate damage based on distance
            const damageMultiplier = Math.max(0.3, 1 - (distance / splashRadius));
            const terrainDamage = Math.floor(damage * damageMultiplier);
            
            this.damageDestructible(terrain, terrainDamage);
            impactedTerrain.push(terrain);
          }
        });
        
        // Create crater at impact point
        if (damage >= 3) { // Only large explosions create craters
          this.createCrater(x, y, Math.min(splashRadius * 0.7, 40));
        }
        
        return impactedTerrain;
      }
      
      static damageDestructible(terrain, damage) {
        if (terrain.destroyed) return;
        
        terrain.health -= damage;
        
        // Update health bar
        const healthPercentage = Math.max(0, terrain.health / terrain.maxHealth);
        terrain.healthFill.style.width = `${healthPercentage * 100}%`;
        
        // Change color as health decreases
        if (healthPercentage > 0.6) {
          terrain.healthFill.style.backgroundColor = '#32cd32'; // Green
        } else if (healthPercentage > 0.3) {
          terrain.healthFill.style.backgroundColor = '#ffa500'; // Orange
        } else {
          terrain.healthFill.style.backgroundColor = '#ff4500'; // Red
        }
        
        // Add damage effect
        terrain.element.style.filter = 'brightness(1.5)';
        setTimeout(() => {
          if (terrain.element) {
            terrain.element.style.filter = 'brightness(1)';
          }
        }, 100);
        
        if (terrain.health <= 0) {
          this.destroyTerrain(terrain);
        }
      }
      
      static destroyTerrain(terrain) {
        if (terrain.destroyed) return;
        
        terrain.destroyed = true;
        
        // Create destruction particles
        ParticleSystem.createExplosionParticles(terrain.x, terrain.y, 6);
        LightingSystem.createExplosionLight(terrain.x, terrain.y, 1);
        
        // Remove visual element with animation
        if (terrain.element) {
          terrain.element.style.transform = 'scale(0)';
          terrain.element.style.opacity = '0';
          setTimeout(() => {
            if (terrain.element && terrain.element.parentNode) {
              terrain.element.remove();
            }
          }, 300);
        }
        
        // Create rubble/debris
        this.createDebris(terrain);
        
        // Check if this creates new paths for enemies
        this.checkForNewPaths(terrain);
      }
      
      static createCrater(x, y, radius) {
        const crater = {
          id: Math.random().toString(36).substr(2, 9),
          x, y, radius,
          created: Date.now(),
          element: null
        };
        
        const craterElement = document.createElement('div');
        craterElement.className = 'crater';
        craterElement.style.position = 'absolute';
        craterElement.style.width = `${radius * 2}px`;
        craterElement.style.height = `${radius * 2}px`;
        craterElement.style.left = `${x - radius}px`;
        craterElement.style.top = `${y - radius}px`;
        craterElement.style.borderRadius = '50%';
        craterElement.style.backgroundColor = 'rgba(80, 60, 40, 0.6)';
        craterElement.style.border = '2px solid rgba(60, 40, 20, 0.8)';
        craterElement.style.boxShadow = 'inset 0 0 10px rgba(0, 0, 0, 0.5)';
        craterElement.style.zIndex = '6';
        craterElement.style.animation = 'craterForm 0.5s ease-out forwards';
        
        // Add crater formation animation
        const style = document.createElement('style');
        style.textContent = `
          @keyframes craterForm {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
          }
        `;
        if (!document.querySelector('style[data-crater-anim]')) {
          style.setAttribute('data-crater-anim', 'true');
          document.head.appendChild(style);
        }
        
        crater.element = craterElement;
        gameState.craters.push(crater);
        gameBoard.appendChild(craterElement);
      }
      
      static createDebris(terrain) {
        // Create small debris pieces
        for (let i = 0; i < 4; i++) {
          const debris = document.createElement('div');
          debris.className = 'terrain-debris';
          debris.style.position = 'absolute';
          debris.style.width = '8px';
          debris.style.height = '8px';
          debris.style.backgroundColor = '#666';
          debris.style.borderRadius = '2px';
          debris.style.zIndex = '6';
          
          const angle = (Math.PI * 2 * i) / 4 + Math.random() * 0.5;
          const distance = terrain.radius + Math.random() * 20;
          const debrisX = terrain.x + Math.cos(angle) * distance;
          const debrisY = terrain.y + Math.sin(angle) * distance;
          
          debris.style.left = `${debrisX - 4}px`;
          debris.style.top = `${debrisY - 4}px`;
          debris.style.animation = 'debrisFall 1s ease-out forwards';
          
          gameBoard.appendChild(debris);
          
          // Remove debris after animation
          setTimeout(() => debris.remove(), 1000);
        }
        
        // Add debris animation if not exists
        const style = document.createElement('style');
        style.textContent = `
          @keyframes debrisFall {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(0) rotate(180deg); opacity: 0.3; }
          }
        `;
        if (!document.querySelector('style[data-debris-anim]')) {
          style.setAttribute('data-debris-anim', 'true');
          document.head.appendChild(style);
        }
      }
      
      static checkForNewPaths(destroyedTerrain) {
        // Check if destroying this terrain opens up new enemy routes
        // This is a simplified implementation - in a full game, you'd use pathfinding
        
        const nearbyEnemies = gameState.enemies.filter(enemy => {
          const dx = enemy.x - destroyedTerrain.x;
          const dy = enemy.y - destroyedTerrain.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance <= 100 && enemy.aiState;
        });
        
        // Give nearby enemies a chance to find new flanking routes
        nearbyEnemies.forEach(enemy => {
          if (enemy.aiState && Math.random() < 0.4) {
            enemy.aiState.behavior = 'advancing'; // Reset behavior to recalculate
            enemy.aiState.lastDecision = 0; // Force immediate decision
          }
        });
      }
      
      static isPositionBlocked(x, y, radius = 15) {
        // Check if position is blocked by destructible terrain
        return gameState.destructibleTerrain.some(terrain => {
          if (terrain.destroyed) return false;
          
          const dx = terrain.x - x;
          const dy = terrain.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < (terrain.radius + radius);
        });
      }
      
      static getBlockingTerrain(x, y, radius = 15) {
        // Get all terrain elements blocking this position
        return gameState.destructibleTerrain.filter(terrain => {
          if (terrain.destroyed) return false;
          
          const dx = terrain.x - x;
          const dy = terrain.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < (terrain.radius + radius);
        });
      }
      
      static cleanup() {
        // Remove all destructible terrain and craters
        gameState.destructibleTerrain.forEach(terrain => {
          if (terrain.element && terrain.element.parentNode) {
            terrain.element.remove();
          }
        });
        
        gameState.craters.forEach(crater => {
          if (crater.element && crater.element.parentNode) {
            crater.element.remove();
          }
        });
        
        gameState.destructibleTerrain = [];
        gameState.craters = [];
        gameState.modifiedPaths = [];
      }
    }

    // Supply Line System
    class SupplyLineSystem {
      static initializeSupplyDepots() {
        gameState.ammoDepots = [];
        
        // Create 2-3 ammo depots around the map edges
        const depotPositions = [
          { x: 50, y: 50 },
          { x: 750, y: 450 },
          { x: 400, y: 25 }
        ];
        
        depotPositions.forEach((pos, index) => {
          const depot = {
            id: Math.random().toString(36).substr(2, 9),
            x: pos.x,
            y: pos.y,
            ammoSupply: 100,
            maxAmmoSupply: 100,
            element: null,
            lastRestock: Date.now(),
            type: 'depot'
          };
          
          this.createDepotElement(depot);
          gameState.ammoDepots.push(depot);
        });
      }
      
      static createDepotElement(depot) {
        const element = document.createElement('div');
        element.className = 'ammo-depot';
        element.style.position = 'absolute';
        element.style.width = '40px';
        element.style.height = '40px';
        element.style.left = `${depot.x - 20}px`;
        element.style.top = `${depot.y - 20}px`;
        element.style.backgroundColor = 'rgba(139, 69, 19, 0.9)';
        element.style.border = '3px solid #8B4513';
        element.style.borderRadius = '10px';
        element.style.cursor = 'pointer';
        element.style.zIndex = '10';
        element.style.display = 'flex';
        element.style.alignItems = 'center';
        element.style.justifyContent = 'center';
        element.style.fontSize = '20px';
        element.textContent = 'üì¶';
        element.style.transition = 'all 0.3s ease';
        element.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
        
        // Add ammo level indicator
        const ammoIndicator = document.createElement('div');
        ammoIndicator.className = 'depot-ammo-indicator';
        ammoIndicator.style.position = 'absolute';
        ammoIndicator.style.bottom = '-8px';
        ammoIndicator.style.left = '0';
        ammoIndicator.style.width = '100%';
        ammoIndicator.style.height = '4px';
        ammoIndicator.style.backgroundColor = '#333';
        ammoIndicator.style.borderRadius = '2px';
        ammoIndicator.style.overflow = 'hidden';
        
        const ammoFill = document.createElement('div');
        ammoFill.className = 'depot-ammo-fill';
        ammoFill.style.height = '100%';
        ammoFill.style.backgroundColor = '#ffa500';
        ammoFill.style.width = '100%';
        ammoFill.style.transition = 'width 0.3s';
        ammoIndicator.appendChild(ammoFill);
        element.appendChild(ammoIndicator);
        
        depot.element = element;
        depot.ammoFill = ammoFill;
        gameBoard.appendChild(element);
        
        // Add hover effect
        element.addEventListener('mouseenter', () => {
          element.style.transform = 'scale(1.1)';
          element.style.boxShadow = '0 4px 12px rgba(255, 165, 0, 0.6)';
        });
        
        element.addEventListener('mouseleave', () => {
          element.style.transform = 'scale(1)';
          element.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.3)';
        });
        
        // Add click handler to manually request supply truck
        element.addEventListener('click', (e) => {
          e.stopPropagation();
          this.requestSupplyDelivery(depot);
        });
      }
      
      static updateSupplySystem(currentTime) {
        // Spawn supply trucks periodically
        if (currentTime - gameState.lastSupplySpawn > 15000 + Math.random() * 10000) {
          this.spawnSupplyTruck();
          gameState.lastSupplySpawn = currentTime;
        }
        
        // Update supply trucks
        this.updateSupplyTrucks(currentTime);
        
        // Restock depots over time
        this.updateDepotRestocking(currentTime);
        
        // Check for low ammo towers that need resupply
        this.checkTowerAmmoNeeds();
      }
      
      static spawnSupplyTruck() {
        // Don't spawn if there are already too many trucks
        if (gameState.supplyTrucks.length >= 3) return;
        
        // Find a depot with ammo to dispatch from
        const availableDepot = gameState.ammoDepots.find(depot => depot.ammoSupply > 20);
        if (!availableDepot) return;
        
        // Find towers that need ammo
        const needyTowers = gameState.towers.filter(tower => 
          tower.maxAmmo > 0 && tower.ammo < tower.maxAmmo * 0.4
        );
        
        if (needyTowers.length === 0) return;
        
        // Pick the most urgent tower (lowest ammo percentage)
        const targetTower = needyTowers.reduce((worst, tower) => {
          const currentRatio = tower.ammo / tower.maxAmmo;
          const worstRatio = worst.ammo / worst.maxAmmo;
          return currentRatio < worstRatio ? tower : worst;
        });
        
        const truck = {
          id: Math.random().toString(36).substr(2, 9),
          x: availableDepot.x,
          y: availableDepot.y,
          targetX: targetTower.x,
          targetY: targetTower.y,
          sourceDepot: availableDepot,
          targetTower: targetTower,
          speed: 2,
          ammoCarried: Math.min(availableDepot.ammoSupply, targetTower.maxAmmo - targetTower.ammo),
          health: 25,
          maxHealth: 25,
          element: null,
          delivered: false,
          underAttack: false
        };
        
        // Deduct ammo from depot
        availableDepot.ammoSupply -= truck.ammoCarried;
        this.updateDepotDisplay(availableDepot);
        
        this.createSupplyTruckElement(truck);
        gameState.supplyTrucks.push(truck);
      }
      
      static createSupplyTruckElement(truck) {
        const element = document.createElement('div');
        element.className = 'supply-truck';
        element.style.position = 'absolute';
        element.style.width = '25px';
        element.style.height = '25px';
        element.style.left = `${truck.x - 12}px`;
        element.style.top = `${truck.y - 12}px`;
        element.style.backgroundColor = '#4CAF50';
        element.style.border = '2px solid #2E7D32';
        element.style.borderRadius = '3px';
        element.style.cursor = 'pointer';
        element.style.zIndex = '11';
        element.style.display = 'flex';
        element.style.alignItems = 'center';
        element.style.justifyContent = 'center';
        element.style.fontSize = '14px';
        element.textContent = 'üöõ';
        element.style.transition = 'all 0.2s ease';
        element.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.3)';
        
        // Add health bar
        const healthBar = document.createElement('div');
        healthBar.className = 'truck-health-bar';
        healthBar.style.position = 'absolute';
        healthBar.style.width = '100%';
        healthBar.style.height = '3px';
        healthBar.style.backgroundColor = '#333';
        healthBar.style.top = '-5px';
        healthBar.style.left = '0';
        healthBar.style.borderRadius = '1px';
        healthBar.style.overflow = 'hidden';
        
        const healthFill = document.createElement('div');
        healthFill.className = 'truck-health-fill';
        healthFill.style.height = '100%';
        healthFill.style.backgroundColor = '#32cd32';
        healthFill.style.width = '100%';
        healthFill.style.transition = 'width 0.2s';
        healthBar.appendChild(healthFill);
        element.appendChild(healthBar);
        
        truck.element = element;
        truck.healthFill = healthFill;
        gameBoard.appendChild(element);
        
        // Add click handler for manual escort
        element.addEventListener('click', (e) => {
          e.stopPropagation();
          this.highlightSupplyRoute(truck);
        });
      }
      
      static updateSupplyTrucks(currentTime) {
        const trucksToRemove = [];
        
        gameState.supplyTrucks.forEach(truck => {
          if (truck.delivered) return;
          
          // Move towards target
          const dx = truck.targetX - truck.x;
          const dy = truck.targetY - truck.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 15) {
            // Truck reached tower
            this.deliverAmmo(truck);
            trucksToRemove.push(truck);
            return;
          }
          
          // Move truck
          truck.x += (dx / distance) * truck.speed;
          truck.y += (dy / distance) * truck.speed;
          
          truck.element.style.left = `${truck.x - 12}px`;
          truck.element.style.top = `${truck.y - 12}px`;
          
          // Check if truck is under attack by enemies
          this.checkTruckUnderAttack(truck);
        });
        
        // Remove delivered trucks
        trucksToRemove.forEach(truck => this.removeSupplyTruck(truck));
      }
      
      static checkTruckUnderAttack(truck) {
        let underAttack = false;
        
        gameState.enemies.forEach(enemy => {
          const dx = enemy.x - truck.x;
          const dy = enemy.y - truck.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 30) {
            underAttack = true;
            
            // Damage truck occasionally
            if (Math.random() < 0.01) { // 1% chance per frame
              truck.health -= enemy.damage;
              truck.healthFill.style.width = `${(truck.health / truck.maxHealth) * 100}%`;
              
              // Change health bar color
              const healthRatio = truck.health / truck.maxHealth;
              if (healthRatio > 0.6) {
                truck.healthFill.style.backgroundColor = '#32cd32';
              } else if (healthRatio > 0.3) {
                truck.healthFill.style.backgroundColor = '#ffa500';
              } else {
                truck.healthFill.style.backgroundColor = '#ff4500';
              }
              
              if (truck.health <= 0) {
                this.destroySupplyTruck(truck);
                return;
              }
            }
          }
        });
        
        // Visual indication of being under attack
        if (underAttack && !truck.underAttack) {
          truck.element.style.animation = 'truckDanger 0.5s infinite';
          truck.underAttack = true;
        } else if (!underAttack && truck.underAttack) {
          truck.element.style.animation = '';
          truck.underAttack = false;
        }
        
        // Add danger animation if not exists
        if (underAttack && !document.querySelector('style[data-truck-danger]')) {
          const style = document.createElement('style');
          style.setAttribute('data-truck-danger', 'true');
          style.textContent = `
            @keyframes truckDanger {
              0%, 100% { filter: brightness(1); }
              50% { filter: brightness(1.5) hue-rotate(45deg); }
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      static deliverAmmo(truck) {
        if (truck.targetTower && !truck.targetTower.element.parentNode) {
          // Tower was destroyed, return ammo to depot
          truck.sourceDepot.ammoSupply += truck.ammoCarried;
          this.updateDepotDisplay(truck.sourceDepot);
          return;
        }
        
        // Deliver ammo to tower
        truck.targetTower.ammo = Math.min(
          truck.targetTower.maxAmmo, 
          truck.targetTower.ammo + truck.ammoCarried
        );
        
        // Update tower ammo bar
        if (truck.targetTower.ammoBar) {
          truck.targetTower.ammoBar.style.width = `${(truck.targetTower.ammo / truck.targetTower.maxAmmo) * 100}%`;
        }
        
        // Stop reloading if tower was reloading
        if (truck.targetTower.reloading) {
          truck.targetTower.reloading = false;
          truck.targetTower.element.style.opacity = '1';
        }
        
        // Visual effect
        ParticleSystem.createExplosionParticles(truck.x, truck.y, 4);
        LightingSystem.createMuzzleLight(truck.x, truck.y);
        
        truck.delivered = true;
      }
      
      static destroySupplyTruck(truck) {
        // Create explosion effect
        ParticleSystem.createExplosionParticles(truck.x, truck.y, 6);
        LightingSystem.createExplosionLight(truck.x, truck.y, 1.2);
        
        // Return ammo to depot
        truck.sourceDepot.ammoSupply += Math.floor(truck.ammoCarried * 0.7); // 70% recovered
        this.updateDepotDisplay(truck.sourceDepot);
        
        this.removeSupplyTruck(truck);
      }
      
      static removeSupplyTruck(truck) {
        if (truck.element && truck.element.parentNode) {
          truck.element.remove();
        }
        
        const index = gameState.supplyTrucks.indexOf(truck);
        if (index !== -1) {
          gameState.supplyTrucks.splice(index, 1);
        }
      }
      
      static updateDepotRestocking(currentTime) {
        gameState.ammoDepots.forEach(depot => {
          if (depot.ammoSupply < depot.maxAmmoSupply) {
            // Restock depot slowly over time
            if (currentTime - depot.lastRestock > 5000) { // Every 5 seconds
              depot.ammoSupply = Math.min(depot.maxAmmoSupply, depot.ammoSupply + 10);
              depot.lastRestock = currentTime;
              this.updateDepotDisplay(depot);
            }
          }
        });
      }
      
      static updateDepotDisplay(depot) {
        if (depot.ammoFill) {
          const ammoRatio = depot.ammoSupply / depot.maxAmmoSupply;
          depot.ammoFill.style.width = `${ammoRatio * 100}%`;
          
          // Change color based on ammo level
          if (ammoRatio > 0.6) {
            depot.ammoFill.style.backgroundColor = '#ffa500'; // Orange
          } else if (ammoRatio > 0.3) {
            depot.ammoFill.style.backgroundColor = '#ff8c00'; // Dark orange
          } else {
            depot.ammoFill.style.backgroundColor = '#ff4500'; // Red orange
          }
        }
      }
      
      static checkTowerAmmoNeeds() {
        // Visual indication for towers that desperately need ammo
        gameState.towers.forEach(tower => {
          if (tower.maxAmmo > 0) {
            const ammoRatio = tower.ammo / tower.maxAmmo;
            
            if (ammoRatio < 0.2 && !tower.lowAmmoIndicator) {
              // Add low ammo indicator
              const indicator = document.createElement('div');
              indicator.className = 'low-ammo-indicator';
              indicator.style.position = 'absolute';
              indicator.style.top = '-10px';
              indicator.style.right = '-10px';
              indicator.style.width = '12px';
              indicator.style.height = '12px';
              indicator.style.backgroundColor = '#ff4500';
              indicator.style.borderRadius = '50%';
              indicator.style.animation = 'lowAmmoPulse 1s infinite';
              indicator.style.zIndex = '15';
              
              tower.element.appendChild(indicator);
              tower.lowAmmoIndicator = indicator;
              
              // Add pulse animation if not exists
              if (!document.querySelector('style[data-ammo-pulse]')) {
                const style = document.createElement('style');
                style.setAttribute('data-ammo-pulse', 'true');
                style.textContent = `
                  @keyframes lowAmmoPulse {
                    0%, 100% { opacity: 0.3; transform: scale(1); }
                    50% { opacity: 1; transform: scale(1.2); }
                  }
                `;
                document.head.appendChild(style);
              }
            } else if (ammoRatio >= 0.4 && tower.lowAmmoIndicator) {
              // Remove low ammo indicator
              tower.lowAmmoIndicator.remove();
              tower.lowAmmoIndicator = null;
            }
          }
        });
      }
      
      static requestSupplyDelivery(depot) {
        // Manual supply truck request
        if (depot.ammoSupply < 20) {
          // Not enough ammo in depot
          return;
        }
        
        // Force spawn a supply truck from this depot
        gameState.lastSupplySpawn = 0; // Reset timer to allow immediate spawn
        this.spawnSupplyTruck();
      }
      
      static highlightSupplyRoute(truck) {
        // Visual indication of supply route
        const route = document.createElement('div');
        route.className = 'supply-route';
        route.style.position = 'absolute';
        route.style.left = `${Math.min(truck.x, truck.targetX)}px`;
        route.style.top = `${Math.min(truck.y, truck.targetY)}px`;
        route.style.width = `${Math.abs(truck.targetX - truck.x)}px`;
        route.style.height = `${Math.abs(truck.targetY - truck.y)}px`;
        route.style.border = '2px dashed #4CAF50';
        route.style.borderRadius = '5px';
        route.style.pointerEvents = 'none';
        route.style.zIndex = '5';
        route.style.opacity = '0.7';
        
        gameBoard.appendChild(route);
        
        // Remove route after 3 seconds
        setTimeout(() => route.remove(), 3000);
      }
      
      static cleanup() {
        // Remove all supply trucks and depots
        gameState.supplyTrucks.forEach(truck => {
          if (truck.element && truck.element.parentNode) {
            truck.element.remove();
          }
        });
        
        gameState.ammoDepots.forEach(depot => {
          if (depot.element && depot.element.parentNode) {
            depot.element.remove();
          }
        });
        
        gameState.supplyTrucks = [];
        gameState.ammoDepots = [];
        gameState.lastSupplySpawn = 0;
      }
    }

    // Map generation system
    class MapGenerator {
      constructor(width = 800, height = 500) {
        this.width = width;
        this.height = height;
        this.gridSize = 25;
        this.seed = Math.random();
      }

      // Simple seeded random number generator
      seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      }

      // Generate procedural path through the map
      generatePath(seed = this.seed) {
        const pathSegments = [];
        const startX = 50 + this.seededRandom(seed) * 100;
        const endX = this.width - 50;
        const startY = this.seededRandom(seed + 1) * this.height;
        
        // Create strategic waypoints with some randomization
        const waypoints = [
          { x: startX, y: startY },
          { x: startX + 150 + this.seededRandom(seed + 2) * 100, y: startY + (this.seededRandom(seed + 3) - 0.5) * 200 },
          { x: this.width * 0.5 + (this.seededRandom(seed + 4) - 0.5) * 150, y: this.height * 0.3 + this.seededRandom(seed + 5) * 200 },
          { x: this.width * 0.7 + (this.seededRandom(seed + 6) - 0.5) * 100, y: this.height * 0.6 + (this.seededRandom(seed + 7) - 0.5) * 150 },
          { x: endX, y: this.height * 0.4 + this.seededRandom(seed + 8) * 200 }
        ];

        // Create curved segments between waypoints
        for (let i = 0; i < waypoints.length - 1; i++) {
          const start = waypoints[i];
          const end = waypoints[i + 1];
          
          // Generate control points for smooth curves
          const controlOffset = 80 + this.seededRandom(seed + i + 10) * 40;
          const control1 = {
            x: start.x + controlOffset * (this.seededRandom(seed + i + 20) - 0.5),
            y: start.y + controlOffset * (this.seededRandom(seed + i + 21) - 0.5)
          };
          const control2 = {
            x: end.x - controlOffset * (this.seededRandom(seed + i + 22) - 0.5),
            y: end.y - controlOffset * (this.seededRandom(seed + i + 23) - 0.5)
          };

          pathSegments.push({
            type: 'curved',
            points: [start, control1, control2, end]
          });
        }

        return pathSegments;
      }

      // Generate strategic terrain features
      generateTerrain(seed = this.seed, pathSegments) {
        const terrain = [];
        const forbiddenAreas = this.calculateForbiddenAreas(pathSegments);

        // Generate resource nodes (provide bonus income)
        const resourceCount = 2 + Math.floor(this.seededRandom(seed + 40) * 2);
        for (let i = 0; i < resourceCount; i++) {
          const resource = this.generateTerrainFeature('resource', seed + 50 + i, forbiddenAreas);
          if (resource) terrain.push(resource);
        }

        // Generate hills (provide tower range bonus)
        const hillCount = 3 + Math.floor(this.seededRandom(seed + 60) * 3);
        for (let i = 0; i < hillCount; i++) {
          const hill = this.generateTerrainFeature('hill', seed + 100 + i, forbiddenAreas);
          if (hill) terrain.push(hill);
        }

        // Generate forests (provide tower concealment)
        const forestCount = 4 + Math.floor(this.seededRandom(seed + 70) * 4);
        for (let i = 0; i < forestCount; i++) {
          const forest = this.generateTerrainFeature('forest', seed + 200 + i, forbiddenAreas);
          if (forest) terrain.push(forest);
        }

        // Generate rocks and decorative elements
        const decorCount = 8 + Math.floor(this.seededRandom(seed + 80) * 8);
        for (let i = 0; i < decorCount; i++) {
          const decor = this.generateTerrainFeature('decoration', seed + 300 + i, forbiddenAreas);
          if (decor) terrain.push(decor);
        }

        return terrain;
      }

      generateTerrainFeature(type, seed, forbiddenAreas) {
        const maxAttempts = 20;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
          const x = 50 + this.seededRandom(seed + attempt) * (this.width - 100);
          const y = 50 + this.seededRandom(seed + attempt + 1000) * (this.height - 100);
          
          if (!this.isPositionForbidden(x, y, forbiddenAreas)) {
            const feature = { x, y, type };
            
            // Add type-specific properties
            if (type === 'resource') {
              feature.radius = 50;
              feature.bonus = 'income';
              feature.icon = 'üí∞';
              feature.income = 2; // Resources per second
              feature.lastIncome = 0;
            } else if (type === 'hill') {
              feature.radius = 60 + this.seededRandom(seed + attempt + 2000) * 40;
              feature.bonus = 'range';
              feature.icon = 'üèîÔ∏è';
            } else if (type === 'forest') {
              feature.radius = 40 + this.seededRandom(seed + attempt + 3000) * 30;
              feature.bonus = 'concealment';
              feature.icon = 'üå≤';
            } else {
              feature.radius = 25;
              feature.icon = ['ü™®', 'üèöÔ∏è', '‚õ™'][Math.floor(this.seededRandom(seed + attempt + 4000) * 3)];
            }
            
            // Add to forbidden areas for future features
            forbiddenAreas.push({
              x: x - feature.radius,
              y: y - feature.radius,
              width: feature.radius * 2,
              height: feature.radius * 2
            });
            
            return feature;
          }
        }
        return null;
      }

      calculateForbiddenAreas(pathSegments) {
        const areas = [];
        pathSegments.forEach(segment => {
          if (segment.type === 'curved') {
            segment.points.forEach(point => {
              areas.push({
                x: point.x - 60,
                y: point.y - 60,
                width: 120,
                height: 120
              });
            });
          }
        });
        return areas;
      }

      isPositionForbidden(x, y, forbiddenAreas) {
        return forbiddenAreas.some(area => 
          x >= area.x && x <= area.x + area.width && 
          y >= area.y && y <= area.y + area.height
        );
      }
    }

    // Global map generator instance
    const mapGenerator = new MapGenerator();
    let pathSegments = [];
    let terrainFeatures = [];

    // Generate path points for enemy movement
    let path = [];
    const pathResolution = 10; // Points per segment

    function generateMapData(seed) {
      mapGenerator.seed = seed || Math.random();
      pathSegments = mapGenerator.generatePath();
      terrainFeatures = mapGenerator.generateTerrain(mapGenerator.seed, pathSegments);
      
      // Generate path points for enemy movement
      path = [];
      pathSegments.forEach(segment => {
        if (segment.type === 'curved') {
          // Generate points along Bezier curve
          for (let t = 0; t <= 1; t += 1/pathResolution) {
            const points = segment.points;
            // Cubic Bezier formula
            const x = Math.pow(1-t, 3) * points[0].x + 
                    3 * Math.pow(1-t, 2) * t * points[1].x + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].x + 
                    Math.pow(t, 3) * points[3].x;
            const y = Math.pow(1-t, 3) * points[0].y + 
                    3 * Math.pow(1-t, 2) * t * points[1].y + 
                    3 * (1-t) * Math.pow(t, 2) * points[2].y + 
                    Math.pow(t, 3) * points[3].y;
            path.push({ x, y });
          }
        }
      });
    }

    // Tower definitions - Authentic WWII representations
    const towerTypes = {
      mg: { 
        name: "MG42 Machine Gun Nest", 
        cost: 25, 
        damage: 2, 
        range: 140, 
        fireRate: 150, // Very fast firing
        targets: ["infantry", "tank", "heavytank"], 
        ammo: 50, 
        maxAmmo: 50, 
        reloadTime: 1500,
        description: "German MG42 'Hitler's Buzzsaw' - devastating rate of fire against infantry",
        specialAbility: "suppression", // Slows down infantry in range
        crewSize: 3,
        armor: "light"
      },
      artillery: { 
        name: "88mm Flak Gun", 
        cost: 60, 
        damage: 8, 
        range: 220, 
        fireRate: 3000, 
        targets: ["infantry", "tank", "heavytank", "aircraft"], // Dual purpose
        splash: 80, 
        ammo: 6, 
        maxAmmo: 6, 
        reloadTime: 4000,
        description: "German 88mm - feared dual-purpose anti-tank and anti-aircraft gun",
        specialAbility: "armor_piercing", // Extra damage to armored targets
        crewSize: 5,
        armor: "medium"
      },
      aa: { 
        name: "Bofors 40mm AA Gun", 
        cost: 45, 
        damage: 4, 
        range: 180, 
        fireRate: 600, 
        targets: ["aircraft"], 
        ammo: 20, 
        maxAmmo: 20, 
        reloadTime: 2500,
        description: "Swedish Bofors 40mm - reliable anti-aircraft defense",
        specialAbility: "tracking", // Improved accuracy against fast targets
        crewSize: 4,
        armor: "light"
      },
      sniper: { 
        name: "Sniper Team", 
        cost: 40, 
        damage: 12, 
        range: 300, 
        fireRate: 4000, 
        targets: ["infantry"], // Specialized anti-personnel
        ammo: 8, 
        maxAmmo: 8, 
        reloadTime: 3000,
        description: "Elite marksman team with scoped rifles",
        specialAbility: "precision", // Can target specific enemy types preferentially
        crewSize: 2,
        armor: "none"
      },
      engineer: { 
        name: "Combat Engineers", 
        cost: 35, 
        damage: 1, 
        range: 80, 
        fireRate: 2000, 
        targets: ["infantry"], 
        ammo: 8, 
        maxAmmo: 8, 
        reloadTime: 3000, 
        special: "construction",
        description: "Versatile engineers - build fortifications and clear obstacles",
        specialAbility: "construction", // Can build additional defenses
        crewSize: 4,
        armor: "light"
      },
      mortar: {
        name: "81mm Mortar Team",
        cost: 50,
        damage: 6,
        range: 200,
        fireRate: 2500,
        targets: ["infantry", "tank"],
        splash: 70,
        ammo: 12,
        maxAmmo: 12,
        reloadTime: 4000,
        description: "High-angle fire support for infantry suppression",
        specialAbility: "indirect_fire", // Can fire over obstacles
        crewSize: 3,
        armor: "none"
      },
      radar: { 
        name: "Radar Station", 
        cost: 70, 
        damage: 0, 
        range: 250, 
        fireRate: 0, 
        targets: [], 
        ammo: 0, 
        maxAmmo: 0, 
        reloadTime: 0, 
        special: "detection",
        description: "Early warning radar - extends detection range of all defensive positions",
        specialAbility: "detection", // Reveals enemy positions and extends range
        crewSize: 6,
        armor: "light"
      },
      command: { 
        name: "Command Bunker", 
        cost: 100, 
        damage: 0, 
        range: 180, 
        fireRate: 0, 
        targets: [], 
        ammo: 0, 
        maxAmmo: 0, 
        reloadTime: 0, 
        special: "support",
        description: "Fortified command post - coordinates defensive operations",
        specialAbility: "command", // Buffs nearby units and coordinates fire
        crewSize: 8,
        armor: "heavy"
      }
    };

    // Enemy definitions
    const enemyTypes = {
      infantry: { name: "Infantry", health: 3, speed: 1, worth: 5, damage: 1, icon: "üë§", scoreValue: 10 },
      tank: { name: "Tank", health: 8, speed: 0.5, worth: 10, damage: 2, icon: "üöú", scoreValue: 25 },
      heavytank: { name: "Heavy Tank", health: 20, speed: 0.3, worth: 20, damage: 4, icon: "üöõ", scoreValue: 50 },
      aircraft: { name: "Aircraft", health: 4, speed: 1.5, worth: 8, damage: 1, icon: "‚úàÔ∏è", scoreValue: 20 }
    };

    // Elite enemy modifiers
    const eliteModifiers = { health: 2, speed: 1.2, worth: 2, scoreValue: 2 };

    // Wave definitions
    const waveDefinitions = [
      { infantry: 10 },
      { infantry: 15, tank: 2 },
      { infantry: 10, aircraft: 5 },
      { infantry: 15, tank: 5 },
      { infantry: 10, tank: 5, aircraft: 5 },
      { infantry: 20, tank: 8 },
      { heavytank: 2, infantry: 10, aircraft: 8 },
      { infantry: 15, tank: 5, aircraft: 10 },
      { infantry: 15, tank: 10, aircraft: 5, heavytank: 2 },
      { infantry: 20, tank: 10, aircraft: 10 },
      { infantry: 25, tank: 15, aircraft: 10, elites: ["tank"] },
      { infantry: 30, tank: 20, aircraft: 15, heavytank: 10, elites: ["heavytank", "aircraft"] }
    ];

    // Difficulty settings
    const difficultySettings = {
      normal: { enemyHealthMultiplier: 1, enemySpeedMultiplier: 1, resourceMultiplier: 1, waveSpawnDelay: 800 },
      hard: { enemyHealthMultiplier: 1.5, enemySpeedMultiplier: 1.01, resourceMultiplier: 0.8, waveSpawnDelay: 600 },
      veteran: { enemyHealthMultiplier: 2, enemySpeedMultiplier: 1.05, resourceMultiplier: 0.6, waveSpawnDelay: 400 }
    };

    // DOM Elements
    const gameBoard = document.getElementById('game-board');
    const waveInfoElement = document.getElementById('wave-info');
    const resourcesElement = document.getElementById('resources');
    const livesElement = document.getElementById('lives');
    const scoreElement = document.getElementById('score-display');
    const startButton = document.getElementById('start-button');
    const gameOverPanel = document.getElementById('game-over');
    const levelCompletePanel = document.getElementById('level-complete');
    const finalScoreElement = document.getElementById('final-score');
    const victoryScoreElement = document.getElementById('victory-score');
    const upgradePanel = document.getElementById('upgrade-panel');

    // Create path visualization
    function createPathVisualization() {
      // Create path segments
      pathSegments.forEach((segment, i) => {
        if (segment.type === 'curved') {
          const points = segment.points;
          // Create path element for this segment
          const pathElement = document.createElement('div');
          pathElement.className = 'path';
          
          // Set path dimensions and position based on the points
          const startX = Math.min(...points.map(p => p.x));
          const startY = Math.min(...points.map(p => p.y));
          const endX = Math.max(...points.map(p => p.x));
          const endY = Math.max(...points.map(p => p.y));
          
          pathElement.style.left = `${startX - 30}px`;
          pathElement.style.top = `${startY}px`;
          pathElement.style.width = `${endX - startX + 60}px`;
          pathElement.style.height = `${endY - startY + 60}px`;
          
          gameBoard.appendChild(pathElement);
        }
      });
    }

    // Add procedurally generated terrain elements
    function addTerrainElements() {
      // Clear existing terrain
      gameState.terrainElements.forEach(element => element.remove());
      gameState.terrainElements = [];
      
      // Add generated strategic terrain
      terrainFeatures.forEach(feature => {
        const terrainElement = document.createElement('div');
        terrainElement.className = `terrain ${feature.type}`;
        terrainElement.textContent = feature.icon;
        terrainElement.style.left = `${feature.x - feature.radius/2}px`;
        terrainElement.style.top = `${feature.y - feature.radius/2}px`;
        terrainElement.style.width = `${feature.radius}px`;
        terrainElement.style.height = `${feature.radius}px`;
        terrainElement.style.fontSize = feature.type === 'decoration' ? '20px' : '24px';
        terrainElement.style.display = 'flex';
        terrainElement.style.alignItems = 'center';
        terrainElement.style.justifyContent = 'center';
        
        // Add bonus indicator for strategic terrain
        if (feature.bonus) {
          const bonusIndicator = document.createElement('div');
          bonusIndicator.className = 'terrain-bonus';
          if (feature.bonus === 'range') {
            bonusIndicator.textContent = '+RNG';
          } else if (feature.bonus === 'concealment') {
            bonusIndicator.textContent = '+CON';
          } else if (feature.bonus === 'income') {
            bonusIndicator.textContent = '+$$$';
          }
          terrainElement.appendChild(bonusIndicator);
          
          // Store terrain data for tower bonuses
          terrainElement.terrainData = feature;
          
          // Add lighting effects for resource nodes
          if (feature.bonus === 'income') {
            LightingSystem.addResourceGlow(terrainElement, feature.x, feature.y);
          }
        }
        
        gameBoard.appendChild(terrainElement);
        gameState.terrainElements.push(terrainElement);
      });
    }

    // Initialize the game
    function initGame() {
      generateMapData(); // Generate new map
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
      
      // Initialize weather system
      WeatherSystem.init();
      
      // Initialize AI system after terrain is generated
      EnemyAI.initializeCoverSystem();
      
      // Initialize destructible terrain system
      DestructibleTerrain.initializeDestructibleElements();
      
      // Initialize supply line system
      SupplyLineSystem.initializeSupplyDepots();
      
      // Set up difficulty selection
      document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('selected'));
          this.classList.add('selected');
          gameState.difficulty = this.getAttribute('data-difficulty');
        });
      });
      
      // Event listener for tower placement
      gameBoard.addEventListener('click', function(event) {
        if (gameState.selectedTowerType) {
          const rect = gameBoard.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          placeTower(x, y);
        }
      });
    }

    // Optimized game loop
    function gameLoop(timestamp) {
      if (!gameState.lastFrameTime) {
        gameState.lastFrameTime = timestamp;
      }
      
      const deltaTime = timestamp - gameState.lastFrameTime;
      gameState.lastFrameTime = timestamp;
      
      if (!gameState.gameOver && !gameState.victory) {
        // Use frame counter to stagger calculations
        gameState.frameCounter++;
        
        // Always update enemy positions every frame
        moveEnemies(deltaTime);
        updateBullets(deltaTime);
        ParticleSystem.updateParticles(deltaTime);
        
        // Stagger more expensive operations
        if (gameState.frameCounter % 2 === 0) {
          checkTowerFiring(deltaTime);
        }
        
        if (gameState.frameCounter % 5 === 0) {
          checkWaveStatus();
          checkTowerReloading();
          updateResourceNodes();
          checkMineExplosions();
          updateCommandBonuses();
          updateSupplyConvoys(deltaTime);
          spawnSupplyConvoy();
          updateTowerAnimations();
        }
        
        if (gameState.frameCounter % 60 === 0) { // Update weather less frequently
          WeatherSystem.updateWeather(timestamp);
        }
        
        if (gameState.frameCounter % 10 === 0) { // Update AI every 10 frames
          EnemyAI.updateEnemyAI(deltaTime);
        }
        
        if (gameState.frameCounter % 30 === 0) { // Update supply system every 30 frames
          SupplyLineSystem.updateSupplySystem(timestamp);
        }
        
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    // Optimized enemy movement along curved path
    function moveEnemies(deltaTime) {
      const enemiesToRemove = [];
      
      gameState.enemies.forEach(enemy => {
        if (enemy.pathIndex >= path.length - 1) {
          // Enemy reached the end
          gameState.lives -= enemy.damage;
          updateInfoPanel();
          enemiesToRemove.push(enemy);
          
          // Check if game over
          if (gameState.lives <= 0) {
            endGame(false);
          }
          return;
        }
        
        // Check if enemy is under AI control for special behaviors
        const aiState = enemy.aiState;
        const isAIControlled = aiState && (
          aiState.behavior === 'seeking_cover' || 
          aiState.behavior === 'in_cover' || 
          aiState.behavior === 'flanking' || 
          aiState.behavior === 'retreating'
        );
        
        // If not under AI control, use normal path movement
        if (!isAIControlled) {
          // Calculate movement along path
          const speedFactor = enemy.speed * (deltaTime / 16) * gameState.enemySpeedMultiplier;
          enemy.pathProgress += speedFactor;
          
          while (enemy.pathProgress >= 1 && enemy.pathIndex < path.length - 1) {
            enemy.pathProgress -= 1;
            enemy.pathIndex++;
          }
          
          // Interpolate position between current and next path point
          const currentPoint = path[enemy.pathIndex];
          const nextIndex = Math.min(enemy.pathIndex + 1, path.length - 1);
          const nextPoint = path[nextIndex];
          
          enemy.x = currentPoint.x + (nextPoint.x - currentPoint.x) * enemy.pathProgress;
          enemy.y = currentPoint.y + (nextPoint.y - currentPoint.y) * enemy.pathProgress;
          
          // Update visual position
          enemy.element.style.left = `${enemy.x - enemy.element.offsetWidth/2}px`;
          enemy.element.style.top = `${enemy.y - enemy.element.offsetHeight/2}px`;
        }
        // AI-controlled movement is handled in the EnemyAI system
      });
      
      // Remove enemies
      enemiesToRemove.forEach(enemy => removeEnemy(enemy));
    }

    // Tower firing with efficiency improvements
    function checkTowerFiring(deltaTime) {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        // Skip special towers that don't fire
        if (tower.special === 'detection' || tower.special === 'support') return;
        
        // Skip if reloading or no ammo
        if (tower.reloading || tower.ammo <= 0) return;
        if (currentTime - tower.lastFired < tower.fireRate) return;
        
        const target = findTarget(tower);
        if (target) {
          fireTower(tower, target);
          tower.lastFired = currentTime;
          tower.ammo--;
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = `${(tower.ammo / tower.maxAmmo) * 100}%`;
          }
          
          // Start reloading if out of ammo
          if (tower.ammo <= 0) {
            startReloading(tower);
          }
        }
      });
    }

    // Batch check tower reloading status
    function checkTowerReloading() {
      const currentTime = Date.now();
      
      gameState.towers.forEach(tower => {
        if (tower.reloading && currentTime - tower.reloadStart >= tower.reloadTime) {
          tower.reloading = false;
          tower.ammo = tower.maxAmmo;
          tower.element.style.opacity = '1';
          
          // Update ammo bar
          if (tower.ammoBar) {
            tower.ammoBar.style.width = '100%';
          }
        }
      });
    }

    // Update resource nodes to generate income
    function updateResourceNodes() {
      const currentTime = Date.now();
      
      terrainFeatures.forEach(feature => {
        if (feature.bonus === 'income') {
          if (currentTime - feature.lastIncome >= 1000) { // Every 1 second
            // Check if any tower is near this resource node
            const nearbyTower = gameState.towers.find(tower => {
              const dx = tower.x - feature.x;
              const dy = tower.y - feature.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              return distance <= feature.radius;
            });
            
            if (nearbyTower) {
              gameState.resources += feature.income;
              updateInfoPanel();
              feature.lastIncome = currentTime;
              
              // Visual feedback
              showResourceGain(feature.x, feature.y, feature.income);
            }
          }
        }
      });
    }

    // Show visual feedback for resource gain
    function showResourceGain(x, y, amount) {
      const popup = document.createElement('div');
      popup.textContent = `+${amount}`;
      popup.style.position = 'absolute';
      popup.style.left = `${x}px`;
      popup.style.top = `${y - 20}px`;
      popup.style.color = '#32cd32';
      popup.style.fontWeight = 'bold';
      popup.style.fontSize = '14px';
      popup.style.pointerEvents = 'none';
      popup.style.zIndex = '15';
      popup.style.animation = 'fadeUpOut 1s forwards';
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes fadeUpOut {
          0% { opacity: 1; transform: translateY(0); }
          100% { opacity: 0; transform: translateY(-30px); }
        }
      `;
      document.head.appendChild(style);
      
      gameBoard.appendChild(popup);
      setTimeout(() => popup.remove(), 1000);
    }

    // Check for mine explosions
    function checkMineExplosions() {
      gameState.mines.forEach((mine, index) => {
        if (mine.triggered) return;
        
        // Check if any enemy is near the mine
        for (let enemy of gameState.enemies) {
          const dx = enemy.x - mine.x;
          const dy = enemy.y - mine.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 20) {
            // Trigger mine explosion
            mine.triggered = true;
            createExplosion(mine.x, mine.y, mine.damage);
            mine.element.remove();
            gameState.mines.splice(index, 1);
            break;
          }
        }
      });
    }

    // Optimized bullet movement and collision detection
    function updateBullets(deltaTime) {
      const bulletsToRemove = [];
      
      gameState.bullets.forEach(bullet => {
        // Move bullet
        const moveSpeed = 0.4 * deltaTime;
        const dx = bullet.targetX - bullet.x;
        const dy = bullet.targetY - bullet.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 0) {
          bullet.x += (dx / distance) * moveSpeed;
          bullet.y += (dy / distance) * moveSpeed;
          bullet.distance += moveSpeed;
        }
        
        bullet.element.style.left = `${bullet.x - 3}px`;
        bullet.element.style.top = `${bullet.y - 3}px`;
        
        // Artillery explosion
        if (bullet.type === 'artillery' && bullet.distance >= bullet.maxDistance * 0.9) {
          createExplosion(bullet.targetX, bullet.targetY, bullet.damage);
          bulletsToRemove.push(bullet);
          return;
        }
        
        // Check for hits using spatial partitioning
        let hitEnemy = null;
        for (let i = 0; i < gameState.enemies.length && !hitEnemy; i++) {
          const enemy = gameState.enemies[i];
          const hitDx = enemy.x - bullet.x;
          const hitDy = enemy.y - bullet.y;
          const hitDistance = Math.sqrt(hitDx * hitDx + hitDy * hitDy);
          
          if (hitDistance < 15) {
            hitEnemy = enemy;
            damageEnemy(enemy, bullet.damage);
          }
        }
        
        // Remove bullet if hit or out of range
        if (hitEnemy || bullet.distance > bullet.maxDistance) {
          bulletsToRemove.push(bullet);
        }
      });
      
      // Batch remove bullets
      bulletsToRemove.forEach(bullet => {
        bullet.element.remove();
        const index = gameState.bullets.indexOf(bullet);
        if (index !== -1) {
          gameState.bullets.splice(index, 1);
        }
      });
    }

    // Special tower implementations
    function addEngineerActions(tower) {
      const actionPanel = document.createElement('div');
      actionPanel.className = 'action-buttons';
      actionPanel.innerHTML = `
        <div class="action-btn" onclick="buildWall(${tower.x}, ${tower.y})">Build Wall ($15)</div>
        <div class="action-btn" onclick="placeMine(${tower.x}, ${tower.y})">Place Mine ($10)</div>
      `;
      tower.element.appendChild(actionPanel);
      
      tower.element.addEventListener('click', (e) => {
        e.stopPropagation();
        document.querySelectorAll('.action-buttons').forEach(panel => panel.style.display = 'none');
        actionPanel.style.display = actionPanel.style.display === 'block' ? 'none' : 'block';
      });
    }

    function activateRadarTower(tower) {
      // Create radar sweep effect
      const radarSweep = document.createElement('div');
      radarSweep.className = 'radar-sweep';
      radarSweep.style.width = `${tower.range * 2}px`;
      radarSweep.style.height = `${tower.range * 2}px`;
      radarSweep.style.left = `-${tower.range - 20}px`;
      radarSweep.style.top = `-${tower.range - 20}px`;
      tower.element.appendChild(radarSweep);
      
      // Enable radar coverage globally
      gameState.radarCoverage = true;
      updateRadarEffects();
    }

    function activateCommandPost(tower) {
      // Create command aura
      const commandAura = document.createElement('div');
      commandAura.className = 'command-aura';
      commandAura.style.width = `${tower.range * 2}px`;
      commandAura.style.height = `${tower.range * 2}px`;
      commandAura.style.left = `-${tower.range - 20}px`;
      commandAura.style.top = `-${tower.range - 20}px`;
      tower.element.appendChild(commandAura);
      
      // Apply bonuses to nearby towers
      updateCommandBonuses();
    }

    function buildWall(engineerX, engineerY) {
      if (gameState.resources < 15) return;
      
      // Find nearby position for wall
      const wallX = engineerX + (Math.random() - 0.5) * 80;
      const wallY = engineerY + (Math.random() - 0.5) * 80;
      
      if (isOnPath(wallX, wallY) || isTowerConflict(wallX, wallY)) return;
      
      gameState.resources -= 15;
      updateInfoPanel();
      
      const wall = document.createElement('div');
      wall.className = 'wall';
      wall.style.left = `${wallX - 10}px`;
      wall.style.top = `${wallY - 10}px`;
      gameBoard.appendChild(wall);
      
      gameState.walls.push({
        x: wallX, y: wallY, element: wall, health: 5, maxHealth: 5
      });
      
      // Walls block enemy movement temporarily
      setTimeout(() => {
        wall.remove();
        const index = gameState.walls.findIndex(w => w.element === wall);
        if (index !== -1) gameState.walls.splice(index, 1);
      }, 30000); // 30 seconds
    }

    function placeMine(engineerX, engineerY) {
      if (gameState.resources < 10) return;
      
      const mineX = engineerX + (Math.random() - 0.5) * 100;
      const mineY = engineerY + (Math.random() - 0.5) * 100;
      
      if (isOnPath(mineX, mineY)) {
        gameState.resources -= 10;
        updateInfoPanel();
        
        const mine = document.createElement('div');
        mine.className = 'mine';
        mine.style.left = `${mineX - 7}px`;
        mine.style.top = `${mineY - 7}px`;
        mine.textContent = 'üí•';
        gameBoard.appendChild(mine);
        
        gameState.mines.push({
          x: mineX, y: mineY, element: mine, damage: 8, triggered: false
        });
      }
    }

    function updateRadarEffects() {
      if (gameState.radarCoverage) {
        // Extend AA tower range by 50%
        gameState.towers.forEach(tower => {
          if (tower.type === 'aa' && !tower.radarBoosted) {
            tower.range *= 1.5;
            tower.radarBoosted = true;
            // Update range indicator
            const rangeIndicator = tower.element.querySelector('.tower-range');
            if (rangeIndicator) {
              rangeIndicator.style.width = `${tower.range * 2}px`;
              rangeIndicator.style.height = `${tower.range * 2}px`;
              rangeIndicator.style.left = `-${tower.range - 20}px`;
              rangeIndicator.style.top = `-${tower.range - 20}px`;
            }
          }
        });
      }
    }

    function updateCommandBonuses() {
      const commandPosts = gameState.towers.filter(t => t.type === 'command');
      
      gameState.towers.forEach(tower => {
        if (tower.type !== 'command') {
          let hasCommandBonus = false;
          
          commandPosts.forEach(commandPost => {
            const dx = tower.x - commandPost.x;
            const dy = tower.y - commandPost.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= commandPost.range) {
              hasCommandBonus = true;
            }
          });
          
          // Apply/remove command bonus
          if (hasCommandBonus && !tower.commandBoosted) {
            tower.damage *= 1.3; // 30% damage boost
            tower.fireRate *= 0.8; // 20% faster firing
            tower.commandBoosted = true;
            tower.element.style.boxShadow = '0 0 8px 2px rgba(154, 205, 50, 0.8)';
          } else if (!hasCommandBonus && tower.commandBoosted) {
            tower.damage /= 1.3;
            tower.fireRate /= 0.8;
            tower.commandBoosted = false;
            tower.element.style.boxShadow = '';
          }
        }
      });
    }

    // Helper functions (tower selection, enemy creation, etc.)
    function selectTower(type) {
      closeUpgradePanel();
      document.querySelectorAll('.action-buttons').forEach(panel => panel.style.display = 'none');
      document.querySelectorAll('.tower-option').forEach(o => o.classList.remove('selected'));
      document.querySelector(`.tower-option[data-type="${type}"]`).classList.add('selected');
      gameState.selectedTowerType = type;
    }

    function placeTower(x, y) {
      if (isOnPath(x, y) || isTowerConflict(x, y) || DestructibleTerrain.isPositionBlocked(x, y, 25)) return;
      
      const towerType = towerTypes[gameState.selectedTowerType];
      if (gameState.resources < towerType.cost) return;
      
      gameState.resources -= towerType.cost;
      updateInfoPanel();
      createTower(x, y, gameState.selectedTowerType);
    }

    function isOnPath(x, y) {
      // Check distance to path points (dynamic path)
      for (let i = 0; i < path.length; i++) {
        const dx = path[i].x - x;
        const dy = path[i].y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < 35) return true; // Slightly larger radius for curved paths
      }
      return false;
    }

    function isTowerConflict(x, y) {
      return gameState.towers.some(tower => {
        const dx = tower.x - x;
        const dy = tower.y - y;
        return Math.sqrt(dx * dx + dy * dy) < 40;
      });
    }

    // Check for terrain bonuses at position
    function getTerrainBonus(x, y) {
      for (let terrainElement of gameState.terrainElements) {
        if (terrainElement.terrainData && terrainElement.terrainData.bonus) {
          const terrain = terrainElement.terrainData;
          const dx = terrain.x - x;
          const dy = terrain.y - y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance <= terrain.radius) {
            return terrain.bonus;
          }
        }
      }
      return null;
    }

    // More efficient tower creation with terrain bonuses
    function createTower(x, y, type) {
      const tower = document.createElement('div');
      tower.className = `tower ${type}`;
      
      // Create turret for rotation (visual styles now handled by CSS)
      const turret = document.createElement('div');
      turret.className = 'tower-turret';
      // No icon needed - using CSS-based visual designs
      tower.appendChild(turret);
      
      // Create barrel for combat towers (not support towers)
      if (towerTypes[type].damage > 0) {
        const barrel = document.createElement('div');
        barrel.className = 'tower-barrel';
        turret.appendChild(barrel);
      }
      
      // Check for terrain bonuses
      const terrainBonus = getTerrainBonus(x, y);
      let baseRange = towerTypes[type].range;
      
      // Apply terrain bonuses
      if (terrainBonus === 'range') {
        baseRange *= 1.25; // 25% range bonus on hills
        tower.style.boxShadow = '0 0 8px 2px rgba(139, 125, 57, 0.6)'; // Golden glow
      } else if (terrainBonus === 'concealment') {
        tower.style.opacity = '0.8'; // Slightly transparent in forests
        tower.style.boxShadow = '0 0 8px 2px rgba(58, 73, 41, 0.6)'; // Green glow
      }
      
      // Create range indicator
      const range = document.createElement('div');
      range.className = 'tower-range';
      range.style.width = `${baseRange * 2}px`;
      range.style.height = `${baseRange * 2}px`;
      range.style.left = `-${baseRange - 20}px`;
      range.style.top = `-${baseRange - 20}px`;
      tower.appendChild(range);
      
      // Create ammo bar
      const ammoBar = document.createElement('div');
      ammoBar.className = 'ammo-bar';
      const ammoFill = document.createElement('div');
      ammoFill.className = 'ammo-fill';
      ammoBar.appendChild(ammoFill);
      tower.appendChild(ammoBar);
      
      // Position tower
      tower.style.left = `${x - 20}px`;
      tower.style.top = `${y - 20}px`;
      gameBoard.appendChild(tower);
      
      // Create tower object with all properties
      const towerObj = {
        x, y, type, element: tower, lastFired: 0,
        damage: towerTypes[type].damage,
        range: baseRange, // Use modified range
        fireRate: towerTypes[type].fireRate,
        targets: towerTypes[type].targets,
        ammo: towerTypes[type].ammo,
        maxAmmo: towerTypes[type].maxAmmo,
        reloadTime: towerTypes[type].reloadTime,
        reloading: false,
        ammoBar: ammoFill,
        level: { damage: 1, range: 1, rate: 1 },
        terrainBonus: terrainBonus, // Store bonus type
        special: towerTypes[type].special || null,
        turret: turret, // Reference to turret element for rotation
        currentRotation: 0 // Track current turret rotation
      };
      
      if (type === 'artillery') {
        towerObj.splash = towerTypes[type].splash;
      }
      
      // Add concealment bonus (AA towers can't target this tower if in forest)
      if (terrainBonus === 'concealment') {
        towerObj.concealed = true;
      }
      
      // Initialize special tower features
      if (type === 'engineer') {
        addEngineerActions(towerObj);
      } else if (type === 'radar') {
        activateRadarTower(towerObj);
      } else if (type === 'command') {
        activateCommandPost(towerObj);
      }
      
      // Add events
      tower.addEventListener('mouseover', () => range.style.display = 'block');
      tower.addEventListener('mouseout', () => range.style.display = 'none');
      tower.addEventListener('click', (e) => {
        e.stopPropagation();
        selectTowerForUpgrade(towerObj);
      });
      
      gameState.towers.push(towerObj);
    }

    // More efficient target finding using spatial partitioning
    function findTarget(tower) {
      let closestEnemy = null;
      let closestDistance = Infinity;
      
      // First pass: filter by type
      const potentialTargets = gameState.enemies.filter(enemy => tower.targets.includes(enemy.type));
      
      // Second pass: find closest in range
      potentialTargets.forEach(enemy => {
        const dx = enemy.x - tower.x;
        const dy = enemy.y - tower.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= tower.range && distance < closestDistance) {
          closestDistance = distance;
          closestEnemy = enemy;
        }
      });
      
      return closestEnemy;
    }

    // Tower upgrade panel
    function selectTowerForUpgrade(tower) {
      gameState.selectedTower = tower;
      
      document.getElementById('upgrade-damage').textContent = `Damage +25% ($${30 * tower.level.damage})`;
      document.getElementById('upgrade-range').textContent = `Range +15% ($${25 * tower.level.range})`;
      document.getElementById('upgrade-rate').textContent = `Fire Rate +20% ($${35 * tower.level.rate})`;
      
      document.getElementById('upgrade-damage').classList.toggle('disabled', gameState.resources < 30 * tower.level.damage);
      document.getElementById('upgrade-range').classList.toggle('disabled', gameState.resources < 25 * tower.level.range);
      document.getElementById('upgrade-rate').classList.toggle('disabled', gameState.resources < 35 * tower.level.rate);
      
      const upgradePanel = document.getElementById('upgrade-panel');
      upgradePanel.style.left = `${tower.x + 30}px`;
      upgradePanel.style.top = `${tower.y - 50}px`;
      upgradePanel.style.display = 'block';
    }

    function closeUpgradePanel() {
      document.getElementById('upgrade-panel').style.display = 'none';
      gameState.selectedTower = null;
    }

    function upgradeTower(upgradeType) {
      if (!gameState.selectedTower) return;
      
      const tower = gameState.selectedTower;
      let cost = 0;
      
      switch (upgradeType) {
        case 'damage':
          cost = 30 * tower.level.damage;
          if (gameState.resources >= cost) {
            tower.damage *= 1.25;
            tower.level.damage++;
          }
          break;
        case 'range':
          cost = 25 * tower.level.range;
          if (gameState.resources >= cost) {
            tower.range *= 1.15;
            tower.level.range++;
            
            const rangeIndicator = tower.element.querySelector('.tower-range');
            rangeIndicator.style.width = `${tower.range * 2}px`;
            rangeIndicator.style.height = `${tower.range * 2}px`;
            rangeIndicator.style.left = `-${tower.range - 20}px`;
            rangeIndicator.style.top = `-${tower.range - 20}px`;
          }
          break;
        case 'rate':
          cost = 35 * tower.level.rate;
          if (gameState.resources >= cost) {
            tower.fireRate *= 0.8;
            tower.level.rate++;
          }
          break;
      }
      
      if (cost && gameState.resources >= cost) {
        gameState.resources -= cost;
        updateInfoPanel();
        
        tower.element.style.transform = 'scale(1.3)';
        setTimeout(() => tower.element.style.transform = 'scale(1)', 300);
        
        closeUpgradePanel();
        selectTowerForUpgrade(tower);
      }
    }

    // Wave management with improved efficiency
    function startWave() {
      if (gameState.waveInProgress) return;
      
      gameState.waveInProgress = true;
      startButton.disabled = true;
      startButton.textContent = 'Wave in Progress';
      
      const waveDefinition = waveDefinitions[gameState.currentWave];
      spawnEnemies(waveDefinition);
      
      if (gameState.animationFrameId === null) {
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
      }
    }

    function spawnEnemies(waveDefinition) {
      const scaledDefinition = scaleWaveForPerformance(waveDefinition);
      const enemiesToSpawn = [];
      const spawnDelay = difficultySettings[gameState.difficulty].waveSpawnDelay;
      
      // Add normal enemies
      Object.entries(scaledDefinition).forEach(([type, count]) => {
        if (type !== 'elites') {
          for (let i = 0; i < count; i++) {
            enemiesToSpawn.push(type);
          }
        }
      });
      
      // Add elite enemies
      if (scaledDefinition.elites) {
        scaledDefinition.elites.forEach(eliteType => {
          const eliteCount = Math.floor(Math.random() * 2) + 2;
          for (let i = 0; i < eliteCount; i++) {
            enemiesToSpawn.push(`elite_${eliteType}`);
          }
        });
      }
      
      // Shuffle and spawn
      shuffleArray(enemiesToSpawn);
      
      enemiesToSpawn.forEach((enemyType, index) => {
        setTimeout(() => {
          if (!gameState.gameOver && !gameState.victory) {
            if (enemyType.includes('elite_')) {
              createEnemy(enemyType.split('_')[1], true);
            } else {
              createEnemy(enemyType, false);
            }
          }
        }, index * spawnDelay);
      });
    }

    // Dynamic wave scaling based on player performance
    function scaleWaveForPerformance(baseWave) {
      const metrics = gameState.performanceMetrics;
      const scaledWave = { ...baseWave };
      
      // Calculate performance score (0.0 to 2.0)
      const killRatio = Math.min(metrics.enemiesKilled / Math.max(gameState.currentWave * 10, 1), 1.5);
      const waveSuccessRate = metrics.wavesCompleted / Math.max(gameState.currentWave, 1);
      const performanceScore = (killRatio + waveSuccessRate + metrics.efficiency / 100) / 3;
      
      // If player is doing well, increase difficulty
      if (performanceScore > 1.2) {
        Object.keys(scaledWave).forEach(enemyType => {
          if (enemyType !== 'elites') {
            scaledWave[enemyType] = Math.floor(scaledWave[enemyType] * 1.3);
          }
        });
        // Add more elite types for high performers
        if (!scaledWave.elites) scaledWave.elites = [];
        const availableElites = ['tank', 'aircraft', 'heavytank'];
        if (scaledWave.elites.length < 2 && gameState.currentWave > 5) {
          scaledWave.elites.push(availableElites[Math.floor(Math.random() * availableElites.length)]);
        }
      }
      // If player is struggling, reduce difficulty
      else if (performanceScore < 0.7) {
        Object.keys(scaledWave).forEach(enemyType => {
          if (enemyType !== 'elites') {
            scaledWave[enemyType] = Math.max(Math.floor(scaledWave[enemyType] * 0.8), 1);
          }
        });
        // Remove some elite enemies for struggling players
        if (scaledWave.elites && scaledWave.elites.length > 0) {
          scaledWave.elites.pop();
        }
      }
      
      return scaledWave;
    }

    // Update performance metrics
    function updatePerformanceMetrics() {
      // Calculate accuracy based on shots fired vs enemies killed
      const totalShots = gameState.bullets.length + gameState.performanceMetrics.enemiesKilled * 2;
      gameState.performanceMetrics.accuracy = Math.max(
        (gameState.performanceMetrics.enemiesKilled / Math.max(totalShots, 1)) * 100, 10
      );
      
      // Calculate efficiency based on resources spent vs enemies killed
      const resourcesSpent = 150 - gameState.resources + gameState.performanceMetrics.enemiesKilled * 5;
      gameState.performanceMetrics.efficiency = Math.min(
        (gameState.performanceMetrics.enemiesKilled * 10 / Math.max(resourcesSpent, 1)) * 100, 200
      );
    }

    // Supply convoy system
    function spawnSupplyConvoy() {
      const currentTime = Date.now();
      
      // Spawn convoy every 45-60 seconds
      if (currentTime - gameState.lastConvoyTime > 45000 + Math.random() * 15000) {
        gameState.lastConvoyTime = currentTime;
        
        const convoy = document.createElement('div');
        convoy.className = 'supply-convoy';
        convoy.textContent = 'üöõ';
        
        // Start from a random edge
        const startSide = Math.floor(Math.random() * 4);
        let startX, startY, targetX, targetY;
        
        switch (startSide) {
          case 0: // Top
            startX = Math.random() * 800;
            startY = -30;
            targetX = Math.random() * 800;
            targetY = 530;
            break;
          case 1: // Right
            startX = 830;
            startY = Math.random() * 500;
            targetX = -30;
            targetY = Math.random() * 500;
            break;
          case 2: // Bottom
            startX = Math.random() * 800;
            startY = 530;
            targetX = Math.random() * 800;
            targetY = -30;
            break;
          case 3: // Left
            startX = -30;
            startY = Math.random() * 500;
            targetX = 830;
            targetY = Math.random() * 500;
            break;
        }
        
        convoy.style.left = `${startX}px`;
        convoy.style.top = `${startY}px`;
        gameBoard.appendChild(convoy);
        
        const convoyObj = {
          x: startX, y: startY, targetX, targetY, element: convoy,
          speed: 2, resources: 25 + Math.floor(Math.random() * 25), // 25-50 resources
          health: 15, maxHealth: 15, collected: false
        };
        
        gameState.supplyConvoys.push(convoyObj);
      }
    }

    function updateSupplyConvoys(deltaTime) {
      const convoysToRemove = [];
      
      gameState.supplyConvoys.forEach((convoy, index) => {
        if (convoy.collected) return;
        
        // Move convoy towards target
        const dx = convoy.targetX - convoy.x;
        const dy = convoy.targetY - convoy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
          convoy.x += (dx / distance) * convoy.speed * (deltaTime / 16);
          convoy.y += (dy / distance) * convoy.speed * (deltaTime / 16);
          
          convoy.element.style.left = `${convoy.x}px`;
          convoy.element.style.top = `${convoy.y}px`;
        } else {
          // Convoy reached target, remove it
          convoysToRemove.push(index);
        }
        
        // Check if player clicks on convoy to collect resources
        convoy.element.addEventListener('click', () => {
          if (!convoy.collected) {
            convoy.collected = true;
            gameState.resources += convoy.resources;
            updateInfoPanel();
            showResourceGain(convoy.x, convoy.y, convoy.resources);
            convoysToRemove.push(index);
          }
        });
        
        // Convoy can be damaged by enemies
        gameState.enemies.forEach(enemy => {
          const dx = enemy.x - convoy.x;
          const dy = enemy.y - convoy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 25) {
            convoy.health -= enemy.damage;
            if (convoy.health <= 0 && !convoy.collected) {
              convoysToRemove.push(index);
            }
          }
        });
      });
      
      // Remove convoys that have been collected or destroyed
      convoysToRemove.reverse().forEach(index => {
        const convoy = gameState.supplyConvoys[index];
        convoy.element.remove();
        gameState.supplyConvoys.splice(index, 1);
      });
    }

    // Core game functions (unchanged but streamlined)
    function createEnemy(type, isElite) {
      const enemy = document.createElement('div');
      enemy.className = `enemy ${type}${isElite ? ' elite' : ''}`;
      enemy.textContent = enemyTypes[type].icon;
      
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      const healthFill = document.createElement('div');
      healthFill.className = 'health-fill';
      healthBar.appendChild(healthFill);
      enemy.appendChild(healthBar);
      
      gameBoard.appendChild(enemy);
      
      // Apply difficulty and elite modifiers
      const difficultyMod = difficultySettings[gameState.difficulty];
      let health = enemyTypes[type].health * difficultyMod.enemyHealthMultiplier;
      let speed = enemyTypes[type].speed * difficultyMod.enemySpeedMultiplier;
      let worth = Math.floor(enemyTypes[type].worth * difficultyMod.resourceMultiplier);
      let scoreValue = enemyTypes[type].scoreValue;
      
      if (isElite) {
        health *= eliteModifiers.health;
        speed *= eliteModifiers.speed;
        worth *= eliteModifiers.worth;
        scoreValue *= eliteModifiers.scoreValue;
      }
      
      const enemyObj = {
        id: Math.random().toString(36).substr(2, 9),
        x: path[0].x, y: path[0].y,
        type, element: enemy,
        pathIndex: 0, pathProgress: 0,
        health, maxHealth: health, speed, worth,
        damage: enemyTypes[type].damage,
        scoreValue, isElite
      };
      
      enemy.style.left = `${enemyObj.x - enemy.offsetWidth/2}px`;
      enemy.style.top = `${enemyObj.y - enemy.offsetHeight/2}px`;
      
      gameState.enemies.push(enemyObj);
    }

    function fireTower(tower, target) {
      // Calculate firing angle for particle effects and turret rotation
      const dx = target.x - tower.x;
      const dy = target.y - tower.y;
      const angle = Math.atan2(dy, dx);
      
      // Rotate turret to face target
      rotateTowerTurret(tower, angle);
      
      // Add firing animation
      tower.element.classList.add('firing');
      setTimeout(() => {
        tower.element.classList.remove('firing');
      }, 200);
      
      // Create muzzle flash particle effect at barrel tip
      const barrelTipX = tower.x + Math.cos(angle) * 25;
      const barrelTipY = tower.y + Math.sin(angle) * 25;
      ParticleSystem.createMuzzleFlash(barrelTipX, barrelTipY, angle);
      
      // Create muzzle flash lighting effect
      LightingSystem.createMuzzleLight(barrelTipX, barrelTipY, angle);
      
      // Create bullet trail effect
      ParticleSystem.createBulletTrail(tower.x, tower.y, target.x, target.y, tower.type);
      
      // Special effects for artillery
      if (tower.type === 'artillery') {
        ParticleSystem.createArtilleryShell(tower.x, tower.y, target.x, target.y);
        LightingSystem.createShellLight(tower.x, tower.y);
      }
      
      const bullet = document.createElement('div');
      bullet.className = `bullet ${tower.type}`;
      gameBoard.appendChild(bullet);
      
      const bulletObj = {
        x: tower.x, y: tower.y,
        targetX: target.x, targetY: target.y,
        element: bullet, damage: tower.damage,
        distance: 0, maxDistance: tower.range * 1.2,
        type: tower.type
      };
      
      bullet.style.left = `${bulletObj.x - 3}px`;
      bullet.style.top = `${bulletObj.y - 3}px`;
      
      gameState.bullets.push(bulletObj);
    }
    
    // Rotate tower turret to face target
    function rotateTowerTurret(tower, angle) {
      if (tower.turret && tower.type !== 'radar') { // Don't interrupt radar rotation
        const degrees = (angle * 180 / Math.PI) + 90; // Convert to degrees and adjust
        tower.turret.style.transform = `rotate(${degrees}deg)`;
        tower.currentRotation = degrees;
      }
    }
    
    // Add idle animations to active towers
    function updateTowerAnimations() {
      gameState.towers.forEach(tower => {
        // Add active class to towers with targets
        const hasTarget = findTarget(tower) !== null;
        if (hasTarget && !tower.element.classList.contains('active')) {
          tower.element.classList.add('active');
        } else if (!hasTarget && tower.element.classList.contains('active')) {
          tower.element.classList.remove('active');
        }
      });
    }

    function startReloading(tower) {
      tower.reloading = true;
      tower.reloadStart = Date.now();
      tower.element.style.opacity = '0.7';
    }

    function createExplosion(x, y, damage) {
      // Create particle explosion effects
      ParticleSystem.createExplosionParticles(x, y, Math.min(damage * 2, 12));
      
      // Create explosion lighting effect
      const lightIntensity = Math.min(damage / 3, 2.5);
      LightingSystem.createExplosionLight(x, y, lightIntensity);
      
      const explosion = document.createElement('div');
      explosion.className = 'explosion';
      explosion.style.left = `${x}px`;
      explosion.style.top = `${y}px`;
      gameBoard.appendChild(explosion);
      
      const splashRadius = 60;
      
      // Damage enemies
      gameState.enemies.forEach(enemy => {
        const dx = enemy.x - x;
        const dy = enemy.y - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= splashRadius) {
          const damageMultiplier = 1 - (distance / splashRadius);
          const splashDamage = Math.round(damage * damageMultiplier);
          if (splashDamage > 0) {
            damageEnemy(enemy, splashDamage);
          }
        }
      });
      
      // Check for destructible terrain impact (artillery only)
      if (damage >= 3) {
        DestructibleTerrain.checkArtilleryImpact(x, y, damage, splashRadius);
      }
      
      setTimeout(() => explosion.remove(), 500);
    }

    function damageEnemy(enemy, damage) {
      enemy.health -= damage;
      
      // Track recent damage for AI system
      enemy.recentDamage = Date.now();
      
      const healthFill = enemy.element.querySelector('.health-fill');
      healthFill.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
      
      if (enemy.health <= 0) {
        gameState.resources += enemy.worth;
        gameState.score += enemy.scoreValue;
        gameState.performanceMetrics.enemiesKilled++;
        updateInfoPanel();
        updatePerformanceMetrics();
        removeEnemy(enemy);
      }
    }

    function removeEnemy(enemy) {
      enemy.element.remove();
      const index = gameState.enemies.findIndex(e => e.id === enemy.id);
      if (index !== -1) {
        gameState.enemies.splice(index, 1);
      }
    }

    function checkWaveStatus() {
      if (gameState.waveInProgress && gameState.enemies.length === 0) {
        gameState.waveInProgress = false;
        gameState.currentWave++;
        gameState.performanceMetrics.wavesCompleted++;
        updatePerformanceMetrics();
        
        if (gameState.currentWave >= gameState.maxWaves) {
          endGame(true);
        } else {
          startButton.disabled = false;
          startButton.textContent = `Start Wave ${gameState.currentWave + 1}`;
        }
        
        updateInfoPanel();
      }
    }

    function updateInfoPanel() {
      waveInfoElement.textContent = `Wave: ${gameState.currentWave}/${gameState.maxWaves}`;
      resourcesElement.textContent = `Resources: ${Math.floor(gameState.resources)}`;
      livesElement.textContent = `Base Health: ${gameState.lives}/20`;
      scoreElement.textContent = `Score: ${gameState.score}`;
    }

    function endGame(victory) {
      if (victory) {
        gameState.victory = true;
        levelCompletePanel.style.display = 'block';
        victoryScoreElement.textContent = gameState.score;
      } else {
        gameState.gameOver = true;
        gameOverPanel.style.display = 'block';
        finalScoreElement.textContent = gameState.score;
      }
      
      closeUpgradePanel();
      cancelAnimationFrame(gameState.animationFrameId);
    }

    function restartGame() {
      // Clear game elements
      gameState.enemies.forEach(enemy => enemy.element.remove());
      gameState.towers.forEach(tower => tower.element.remove());
      gameState.bullets.forEach(bullet => bullet.element.remove());
      gameState.terrainElements.forEach(element => element.remove());
      gameState.walls.forEach(wall => wall.element.remove());
      gameState.mines.forEach(mine => mine.element.remove());
      gameState.supplyConvoys.forEach(convoy => convoy.element.remove());
      ParticleSystem.clearAllParticles();
      LightingSystem.clearAllLights();
      WeatherSystem.clearWeatherEffects();
      EnemyAI.cleanupAI();
      DestructibleTerrain.cleanup();
      SupplyLineSystem.cleanup();
      gameState.terrainElements = [];
      
      // Reset game state
      Object.assign(gameState, {
        resources: 150, lives: 20, currentWave: 0, waveInProgress: false,
        gameOver: false, victory: false, selectedTowerType: null, selectedTower: null,
        towers: [], enemies: [], bullets: [], animationFrameId: null,
        score: 0, lastFrameTime: 0, frameCounter: 0, enemySpeedMultiplier: 0.4,
        walls: [], mines: [], radarCoverage: false, nextWavePreview: null, supplyConvoys: [],
        lastConvoyTime: 0, weather: { type: 'clear', intensity: 0, lastChange: 0 },
        coverSpots: [], enemyGroups: [], lastAIUpdate: 0,
        destructibleTerrain: [], craters: [], modifiedPaths: [],
        supplyTrucks: [], ammoDepots: [], lastSupplySpawn: 0,
        performanceMetrics: { enemiesKilled: 0, wavesCompleted: 0, accuracy: 100, efficiency: 100 }
      });
      
      // Reset UI
      startButton.disabled = false;
      startButton.textContent = 'Start Wave 1';
      gameOverPanel.style.display = 'none';
      levelCompletePanel.style.display = 'none';
      upgradePanel.style.display = 'none';
      document.querySelectorAll('.tower-option').forEach(option => {
        option.classList.remove('selected');
      });
      
      // Reinitialize game with new map
      generateMapData(); // Generate new random map
      createPathVisualization();
      addTerrainElements();
      updateInfoPanel();
      
      // Reinitialize AI system
      EnemyAI.initializeCoverSystem();
      
      // Reinitialize destructible terrain
      DestructibleTerrain.initializeDestructibleElements();
      
      // Reinitialize supply system
      SupplyLineSystem.initializeSupplyDepots();
    }

    // Generate a new map without resetting the game
    function generateNewMap() {
      if (gameState.waveInProgress) {
        alert("Cannot generate new map during a wave!");
        return;
      }
      
      // Clear existing map elements
      gameState.terrainElements.forEach(element => element.remove());
      gameState.terrainElements = [];
      
      // Clear existing path visualization
      document.querySelectorAll('.path').forEach(path => path.remove());
      
      // Generate new map
      generateMapData();
      createPathVisualization();
      addTerrainElements();
      
      // Reinitialize AI for new terrain
      EnemyAI.initializeCoverSystem();
      
      // Reinitialize destructible terrain for new map
      DestructibleTerrain.cleanup();
      DestructibleTerrain.initializeDestructibleElements();
      
      // Reinitialize supply system for new map
      SupplyLineSystem.cleanup();
      SupplyLineSystem.initializeSupplyDepots();
    }

    // Utility functions
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Initialize the game
    initGame();
  </script>
</body>
</html>